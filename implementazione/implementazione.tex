%https://denizhalil.com/2024/04/06/sending-icmp-packets-with-python-socket-adventure-in-signaling/
%https://thepythoncode.com/article/crafting-packets-with-scapy-in-python
%
%SITI SECONDARI
%https://stackoverflow.com/questions/2953462/pinging-servers-in-python
%https://docs.python.org/3/library/socket.html
%https://stackoverflow.com/questions/8245344/python-icmp-socket-server-not-tcp-udp
%
\section{Strumenti usati per l'implmentazione}

%https://pypi.org/project/icmplib/
%https://github.com/ValentinBELYN/icmplib/tree/main
%https://github.com/ValentinBELYN/icmplib
%https://pypi.org/project/icmplibs/
%
\subsection{icmplib }
icmplib is a brand new and modern implementation of the ICMP protocol in Python.
Use the built-in functions or build your own, you have the choice!

%Features
%ðŸŒ³ Ready-to-use: icmplib offers ready-to-use functions such as the most popular ones: ping, multiping and traceroute. An extensive documentation also helps you get started.
%ðŸ’Ž Modern: This library uses the latest mechanisms offered by Python 3.7+ and is fully object-oriented.
%ðŸš€ Fast: Each class and function has been designed and optimized to deliver the best performance. Some functions are also asynchronous like the async_ping and async_multiping functions. You can ping the world in seconds!
%âš¡ï¸ Powerful: Use the library without root privileges, set the traffic class of ICMP packets, customize their payload, send broadcast requests and more!
%ðŸ”© Evolutive: Easily build your own classes and functions with ICMPv4 and ICMPv6 sockets.
%ðŸ”¥ Seamless integration of IPv6: Use IPv6 the same way you use IPv4.
%ðŸº Cross-platform: Optimized for Linux, macOS and Windows. The library automatically manages the specificities of each system.
%ðŸ¤˜ No dependency: icmplib is a pure Python implementation of the ICMP protocol. It does not rely on any external dependency.

The recommended way to install icmplib is to use pip3:
\begin{lstlisting}
    $ pip3 install icmplib
\end{lstlisting}

Import basic functions
\begin{lstlisting}
    from icmplib import ping, multiping, traceroute, resolve
\end{lstlisting} 
Import asynchronous functions
\begin{lstlisting}
    from icmplib import async_ping, async_multiping, async_resolve
\end{lstlisting} 
Import sockets (advanced)
\begin{lstlisting}
    from icmplib import ICMPv4Socket, ICMPv6Socket, AsyncSocket, ICMPRequest, ICMPReply
\end{lstlisting} 
Import exceptions
\begin{lstlisting}
    from icmplib import ICMPLibError, NameLookupError, ICMPSocketError
    from icmplib import SocketAddressError, SocketPermissionError
    from icmplib import SocketUnavailableError, SocketBroadcastError, TimeoutExceeded
    from icmplib import ICMPError, DestinationUnreachable, TimeExceeded
\end{lstlisting}

Send ICMP Echo Request packets to a network host.
\begin{lstlisting}
    ping(address, count=4, interval=1, timeout=2, id=None, source=None, family=None, privileged=True, **kwargs)
\end{lstlisting}
\begin{itemize}
    \item address Type: str.
    The IP address, hostname or FQDN of the host to which messages should be sent. 
    For deterministic behavior, prefer to use an IP address.
    \item count Type: int Default: 4. The number of ping to perform.
    \item interval Type: int or float Default: 1. The interval in seconds between sending each packet.
    \item timeout Type: int or float Default: 2. The maximum waiting time for receiving a reply in seconds.
    \item id Type: int Default: None. The identifier of ICMP requests. Used to match the responses with requests. In practice, a unique identifier should be used for every ping process. On Linux, this identifier is ignored when the privileged parameter is disabled. The library handles this identifier itself by default.
    \item source Type: str Default: None. The IP address from which you want to send packets. By default, the interface is automatically chosen according to the specified destination.
    \item family Type: int Default: None. The address family if a hostname or FQDN is specified. Can be set to 4 for IPv4 or 6 for IPv6 addresses. By default, this function searches for IPv4 addresses first before searching for IPv6 addresses.
    \item privileged Type: bool Default: True. When this option is enabled, this library fully manages the exchanges and the structure of ICMP packets. Disable this option if you want to use this function without root privileges and let the kernel handle ICMP headers.
    \item payload Type: bytes Default: None. The payload content in bytes. A random payload is used by default.
    \item payload\_size Type: int Default: 56. The payload size. Ignored when the payload parameter is set.
    \item traffic\_class Type: int Default: 0. The traffic class of ICMP packets. 
    Provides a defined level of service to packets by setting the DS Field (formerly TOS) or the Traffic Class field of IP headers. 
    Packets are delivered with the minimum priority by default (Best-effort delivery). 
    Intermediate routers must be able to support this feature. 
    Only available on Unix systems. Ignored on Windows.
\end{itemize}
Return value: A Host object containing statistics about the desired destination:
\begin{itemize}
    \item address, min\_rtt, avg\_rtt, max\_rtt, rtts, packets\_sent, packets\_received, packet\_loss, jitter, is\_alive
\end{itemize}

Send ICMP Echo Request packets to a network host.
\begin{lstlisting}
    async_ping(address, count=4, interval=1, timeout=2, id=None, source=None, family=None, privileged=True, **kwargs)
\end{lstlisting}
The same parameters, return value and exceptions as for the ping function.


%https://stackoverflow.com/questions/34614893/how-is-an-icmp-packet-constructed-in-python
%https://github.com/Akhavi/pyping/blob/master/pyping/core.py
%https://github.com/Akhavi/pyping/tree/master
\subsection{How is an ICMP packet constructed in python}
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.7\linewidth]{../implementazione/img/icmp_structure.jpeg}
    \captionof{figure}{Struttura dei pacchetti ICMP}
    \label{fig:icmp:struttuera} 
\end{minipage}
%
\subsubsection{Header Generation}
\begin{lstlisting}
    header = struct.pack(
        "!BBHHH", ICMP_ECHO, 0, checksum, self.own_id, self.seq_number
    )
\end{lstlisting}
\textbf{self.own\_id} sets the identifier of the application sending this data. 
For this code, it just uses the program's Program Identifier number.
\vspace{1ex}\newline
\textbf{self.seq\_number} sets the sequence number. 
This helps you identify which ICMP request packet this is if you were to send multiple in a row. 
It would help you do things like calculate ICMP packet loss.
\vspace{2ex}\newline
This line creates the packet header using struct with layout !BBHHH, which means:
\begin{itemize}
    \item B - Unsigned Char (8 bits)
    \item B - Unsigned Char (8 bits)
    \item H - Unsigned Short (16 bits)
    \item H - Unsigned Short (16 bits)
    \item H - Unsigned Short (16 bits)
\end{itemize}
And so the header will look like this:
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.7\linewidth]{../implementazione/img/icmp_head_struct.jpeg}
    \captionof{figure}{Struttura dei pacchetti ICMP}
    \label{fig:icmp:struttuera} 
\end{minipage}
%
\subsubsection{Payload  Generation}
Payloads are of arbitrary length, but the Ping class this code is taken from defaults to a total packet payload size of 55 bytes.
So the portion below just creates a bunch of arbitrary bytes to stuff into the payload section.
\begin{lstlisting}
    padBytes = []
    startVal = 0x42

    # Annotation: 0x42 = 66 decimal
    # This loop would go from [66, 66 + packet_size],
    # which in default pyping means [66, 121)
    for i in range(startVal, startVal + (self.packet_size)):
        padBytes += [(i & 0xff)]  # Keep chars in the 0-255 range
    data = bytes(padBytes)
\end{lstlisting}
At the end of it, byte(padBytes) actually looks like this:
\begin{lstlisting}
    >> bytes(padBytes)
    b'BCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx'
\end{lstlisting}
As far as I know, 0x42 has no actual significance as a Payload identifier, so this seems rather arbitrary. 
The payload here is actually pretty meaningless. As you can see from the Payload Generation section, it just generates a contiguous sequence that doesn't really mean anything. 
They could have just decided to fill the entire packet payload with 0x42 bytes if they wanted.


%https://scapy.readthedocs.io/en/latest/index.html
%https://github.com/secdev/scapy
\subsection{Scapy}
Scapy is packet manipulation framework written in python. 
You can forge a lot of kind of packets (http, tcp, ip, udp, icmp, etc...)
\vspace{2ex}\newline
Scapy is a powerful Python-based interactive packet manipulation program and library.
\vspace{1ex}\newline
It is able to forge or decode packets of a wide number of protocols, send them on the wire, capture them, store or read them using pcap files, match requests and replies, and much more. 
It is designed to allow fast packet prototyping by using default values that work.
\vspace{1ex}\newline
It can easily handle most classical tasks. 


%https://pypi.org/project/ping3/
%https://github.com/kyan001/ping3
\subsection{ping3}
Ping3 is a pure python3 version of ICMP ping implementation using raw socket.
(Note that on some platforms, ICMP messages can only be sent from processes running as root.)


%https://github.com/toxinu/pyping
\subsection{pyping}
A pure python ping implementation using raw sockets.


%https://github.com/pferate/python_ping
%https://github.com/samuel/python-ping/blob/master/ping.py
\subsection{python\_ping}
A pure python ping implementation using raw sockets.


%https://github.com/samuel/python-ping/blob/master/ping.py
%https://github.com/pferate/python_ping