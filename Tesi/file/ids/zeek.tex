Zeek includes an event-driven scripting language that provides the primary means for an organization to extend and customize Zeek’s functionality.
Virtually all of the output generated by Zeek is, in fact, generated by Zeek scripts


First, there is a base level with no indentation where libraries are 
included in the script through @load and a namespace is defined with module
This is followed by an indented and formatted section explaining the custom variables 
being provided (export) as part of the script’s namespace

    The @load directives are ensuring the Files framework, the Notice framework and the script to hash all 
    files has been loaded by Zeek.

    The export section redefines an enumerable constant that describes the type of notice we will generate with 
    the Notice framework. Zeek allows for re-definable constants. By extending the Notice::Type as shown, 
    this allows for the NOTICE function to generate notices with a \$note field set as 
    TeamCymruMalwareHashRegistry::Match. Notices allow Zeek to generate some kind of 
    extra notification beyond its default log types. 

    Up until this point, the script has merely done some basic setup. 
    With the next section, the script starts to define instructions to take in a given event.






Finally there is a second indented and formatted section describing the 
instructions to take for a specific event (event file\_hash)


    The workhorse of the script is contained in the event handler for file_hash. 
    The file\_hash event allows scripts to access the information associated with a file for which Zeek’s file 
    analysis framework has generated a hash. The event handler is passed the file itself as f, the type of 
    digest algorithm used as kind and the hash generated as hash.

    In the file_hash event handler, there is an if statement that is used to check for the correct type of hash, 
    in this case a SHA1 hash.



Zeek’s scripting language is event driven
Scripting in Zeek depends on handling the events generated by Zeek as it processes network traffic, 
altering the state of data structures through those events, and making decisions on the information provided
Zeek’s core acts to place events into an ordered “event queue”, allowing event handlers 
to process them on a first-come-first-serve basis
The majority of events generated by Zeek are defined in the built-in-function (*.bif) files which 
also act as the basis for online event documentation. 





Of all the events defined by Zeek, an overwhelmingly large number of them are passed the connection 
record data type, in effect, making it the backbone of many scripting solutions. The connection record itself, 
as we will see in a moment, is a mass of nested data types used to track state 
on a connection through its lifetime


Zeek defines events for the primary parts of the connection life-cycle, such as the following:
    new_connection
    connection_timeout
    connection_state_remove



Zeek makes extensive use of nested data structures to store state and information gleaned 
from the analysis of a connection as a complete unit. To break down this collection of information, 
you will have to make use of Zeek’s field delimiter \$


Zeek uses the dollar sign as its field delimiter and a direct correlation exists between the 
output of the connection record and the proper format of a dereferenced variable in scripts. 
In the output of the script above, groups of information are collected between brackets, 
which would correspond to the \$-delimiter in a Zeek script.





The declarations of variables in Zeek come in two forms. Variables can be declared with or without a definition 
in the form SCOPE name: TYPE or SCOPE name = EXPRESSION respectively; each of which produce the same result 
if EXPRESSION evaluates to the same type as TYPE.



A global variable is used when the state of variable needs to be tracked, not surprisingly, globally. 
While there are some caveats, when a script declares a variable using the global scope, that script is 
granting access to that variable from other scripts. However, when a script uses the module keyword to give 
the script a namespace, more care must be given to the declaration of globals to ensure the intended result.



Global Variables
When a global is declared in a script with a namespace there are two possible outcomes. 
First, the variable is available only within the context of the namespace. In this scenario, 
other scripts within the same namespace will have access to the variable declared while scripts using a 
different namespace or no namespace altogether will not have access to the variable.
Alternatively, if a global variable is declared within an export { ... } block that variable is available to 
any other script through the naming convention of <module name>::<variable name>, i.e. the variable needs to 
be “scoped” by the name of the module in which it was declared

When the module keyword is used in a script, the variables declared are said to be in that module’s “namespace”. 
Where as a global variable can be accessed by its name alone when it is not declared within a module, a global 
variable declared within a module must be exported and then accessed via <module name>::<variable name>.



Constants 
Zeek also makes use of constants, which are denoted by the const keyword. Unlike globals, constants can only be 
set or altered at parse time if the &redef attribute has been used. Afterwards (in runtime) the constants are 
unalterable. In most cases, re-definable constants are used in Zeek scripts as containers for configuration options.



Local Variables
Whereas globals and constants are widely available in scriptland through various means, when a 
variable is defined with a local scope, its availability is restricted to the body of the event 
or function in which it was declared. Local variables tend to be used for values that are only 
needed within a specific scope and once the processing of a script passes beyond that scope and 
no longer used, the variable is deleted. 



Data Structures 
Some of the more interesting characteristics of data types are revealed when used inside of a data structure, but given that data structures are made up of data types, it devolves rather quickly into a “chicken-and-egg” problem
The table below shows the atomic types used in Zeek: 
int 
count 
double 
bool 
addr 
port 
subnet 
time 
interval 
pattern





