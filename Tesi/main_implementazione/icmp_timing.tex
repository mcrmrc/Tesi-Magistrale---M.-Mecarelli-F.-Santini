Per poter temporizzare i dati da inviare, c'è bisogno sia di un metodo per la codifica e decodifica dei tempi. 
Dovrà quindi essere presente una funzione che è responsabile di mappare un dato binario a un intervallo di tempo. 
\vspace{1ex} \newline  
Per la \textbf{codifica}, si calcolerà dal dato il delay associato; che verrà usato per indicare il tempo da aspetare prima di inviare un nuovo pacchetto. 
%metodo di codifica, usato dal mittente, che ricaverà il tempo associato ad un dato e poi aspetterà tale intervallo di tempo. 
Per esempio al dato binario 1001 potrebbe essere associato il tempo 3; quindi il programma, prima di mandare un nuovo pacchetto, aspetterà tre secondi. 
\vspace{1ex} \newline
Invece per la \textbf{decodifica}, il destinatario rimane in attesa dei pacchetti che gli vengono inviati. 
Ogni volta calcolerà l'intervallo di tempo fra un pacchetto e il successivo, e da quello ricaverà il dato che gli è associato. 
%Successivamente ricaverà l'intervallo di tempo fra il pacchetto precedente e quello corrente e poi ricaverà il valore associato. 
Per esempio se l'intervallo di tempo risultasse di 6 secondi, il destinatario controllerà a chi è associato tale tempo e ricaverà il dato binario 1101. 
%In questo caso si definisce un Covert Channel Temporale inviando pacchetti ICMP (di tipo Echo) in intervalli specifici. 
%Tramite la differenza fra il tempo precedente e il tempo di ircezione del nuovo pacchetto; 
%l'attaccante riuscirà a codificare un bit (o coppie di bit) mentre la vittima riuscirà a decodificare il bit (o la coppia di bit) associato all'intervallo. 
%In altre parole: ogni possibile combinazione dei valori assumibili dal byte, si può vedere
%come un punti su una linea retta (la linea del tempo). 
\vspace{3ex} \newline 
Per l'invio dei dati, si è preso spunto dall'approccio implementato in ICMP Exfill \cite{icmp-exfill} 
nel quale il delay viene determinato dal valore del byte che si vuole esfiltrare. 
Ciò è possibile siccome un carattere di un testo viene memorizzato tramite una sequenza di bit 
la quale potrà essere interpretata anche come un numero intero.
%L'intervallo di tempo verrà quindi ricavato dall'intero associato al byte da codificare. 
%viene quindi ricavato convertendo in un intero la rappresentazione in memoria dei bit presenti. 
%Il byte rappresentante il carattere, verrà quindi letto come un numero intero ed usato per determinar il tempo di delay. 


\subsubsection{Funzione di codifica} 
In una \textbf{prima versione} della funzione si associa ad ogni punto una distanza di sicurezza, 
coì da evitare che due codici combacino verso lo stesso tempo di delay [Figura \ref{fig:covertTiming:intervalli:distanza}]. 
Infatti durante la trasmissione dela pacchetto possono avvenire dei ritardi non costanti per tutti 
i datagram inviati \cite{packet_delay1}\cite{packet_delay2}. 
%\vspace{1ex} \newline 
%Generalmente questi ritardi sono dati dal tempo di propagazione\footnote{tempo richiesto affinchè l'ultimo bit raggiunga la destinazione} 
%e il tempo di coda\footnote{tempo in cui il datagram aspetta nella buffer di destinazione}. 
%Inoltre sono presenti anche il tempo di trasmissione \footnote{tempo richiesto da un host per trasmettere il pacchetto nel canale di trasmisisone} 
%e il tempo di elaborazione\footnote{tempo richiesto dai router intermedi per inoltrare il pacchetto} 
%il tempo in cui la destinazione riceverà il messaggio è dato dal delay per codificare il dato 
%più il ritardo di rete. 
La variazione del valore di questo parametro dipenderà dall'ubicazione geografica dell'entità mittente 
e di quella destinataria, oltre alla reattività delle due macchine.
\vspace{1ex} \newline 
La mediana di questo valore \cite{latency_statistics} è di solito 122 ms (o 0.122 s) con un 
massimo di 266 ms (o 0.266 s)
\footnote{i dati presi in analisi sono quelli relativi all'Italia}. 
%\href{https://learn.microsoft.com/en-us/azure/networking/azure-network-latency?tabs=Americas%2CWestUS}{text}
%https://andrewpakhomov.com/posts/latency-tail-latency-and-response-time-in-distributed-systems/
%https://www.kentik.com/kentipedia/network-latency-understanding-impacts-on-network-performance/
%La formula per calcolare i tempi associati alle codifiche dei bit è la seguente: \newline
\begin{equation}
    %\text{tempo\_base}+\text{indice}*(2*\text{distanza\_tempi})
    \text{tempo\_base}+\text{indice}*\text{distanza\_tempi}
\end{equation}
\label{equation:1:tempi:timingCC}
Il significato dei parametri è descritto nella seguente tabella [Tabella \ref{tabella:timingCC:parametri:funzione1} ].
%\begin{lstlisting}
%DISTANZA_TEMPI=2 #sec 
%TEMPI_CODICI=[3+index*2*DISTANZA_TEMPI for index in range(2**2)] #00, 01, 10, 11 
%TEMPO_BYTE=0*60 #minuti
%\end{lstlisting} 
%\captionof{lstlisting}{heading} 
%Si definisce un \textbf{tempo di base} di \textit{3 secondi} e una \textbf{distanza} minima che tutti i tempi dovranno avere. 
%In questo caso si è deciso che la distanza sia di almeno \textit{2 secondi}. 
\begin{center} 
\begin{longtable}{|p{0.25\textwidth}|p{0.55\textwidth}|} 
    \hline
    \textbf{Parametro} & \textbf{Descrizione} \\
    \hline
    \textbf{Tempo di base} &  
    Il minimo di secondi che si dovrà aspettare per ciascun possibile dato. 
    \uppercase{è} necessario per evitare di causare un overflow di pacchetti verso la macchina che riceve i dati.
    \\
    \hline 
    \textbf{Indice} & 
    \uppercase{è} l'indice associato alla codifica del dato. 
    Il suo valore và da 0 sino a 255 siccome si prende un byte alla volta. 
    %al masismo numero di codifiche possibili per i dati. 
    %Siccome si trattano bit, corrisponderà all'intero rappresentato dalla coppia di bit (eg 101=5). 
    \\ 
    \hline 
    \textbf{Distanza fra i tempi} & 
    Distanza minima di secondi che tutte le codifiche dovranno avere fra di loro. 
    %Lo scopo è evitare che i tempi relativi a due codifiche si sovrappongano. 
    %In quei casi la decodifica potrà essere erronea. 
    \\ 
    \hline 
\caption{Parametri della prima funzione (Timing Channel)} 
\label{tabella:timingCC:parametri:funzione1} 
\end{longtable} 
\end{center} 
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./img/timing_channel/timing_channel_times_nonoverlapping.png}
    \captionof{figure}{Assegnazione degli intervalli con la distanza} %di tempo 
    \label{fig:covertTiming:intervalli:distanza}
\end{minipage} 
%\begin{minipage}{\textwidth}
%    \includegraphics[width=\textwidth]{./img/timing_channel/timing_channel_times_overlapping.png}
%    \captionof{figure}{Funzione 1: Assegnazione degli intervalli senza la distanza}  %di tempo 
%\end{minipage}  
%\begin{minipage}{\textwidth}
%    \includegraphics[width=\textwidth]{./img/timing_channel/timinmg_channel_network_latency.png}
%    \captionof{figure}{Schema latenza nel sistema} 
%\end{minipage}  
\vspace{1ex} \newline 
Lo svantaggio di questo approccio sono i tempi che si aspettano. 
Nel miglior caso si aspetterà solo il tempo di base 
nel caso peggiore invece 255 volte la distanza scelta.  
%Nel caso in cui il byte rappresenti l'intero 0 si aspetterà solo il tempo di base; 
%invece nel caso in cui il byte rappresenti l'intero 255 si aspetteà il $\text{tempo di base}+255*\text{distanza}$. 
%Supponendo che il tempo di base sia di 3 secondi e che la distanza fra i vari tempi sia di 
%600 ms (o 0.6 secondi) nel caso peggiore si aspetteranno 156 secondi (ovvero circa tre minuti). 
\vspace{1ex} \newline 
Cercando di avere una stima più precisa, si sa che i caratteri stampabili vanno da 32 a 126 \cite{unicode_printable_char}. 
Da ciò si ricava che in media si aspetterà 79 \footnote{$\text{tempo base}+\frac{32+126}{2}*\text{distanza}$} volte la distanza scelta.  
%\vspace{1ex} \newline 
%Un ulteriore affinamento è tramite la frequenze delle lettere con cui appaiono sia nella lingua 
%inglese che in quella italiana \cite{letter_frquency}. 
%Se invece si analizzasse un caso realistico, tramite la frequenza 
%delle lettere nel testo inglese \cite{letter_frquency}, 
%si avrà in media un tempo di attesa di 57 secondi. 
%La prima avrà un tempo di attesa pari a 107 volte la distanza mentre l'ultima di 105 volte.
%\vspace{2ex} \newline 
%Se si suppone che il tempo di base sia di 3 secondi e che la distanza fra i vari tempi sia di 600 ms (o 0.6 secondi)
%Ciò si traduce in un tempo di attesa di 68 secondi per i testi inglesi mentre di 66 secondi per quelli italiani. 
Supp che il tempo di base sia di 3 secondi e che la distanza fra i tempi sia di 0.6 secondi (600 ms); in media si aspetteranno circa 51 secondi. 
%
\vspace{4ex} \newline 
\uppercase{è} quindi richiesta un \textbf{seconda implementazione} per evitare tempi di attesa 
eccessivamente lunghi per l'invio dei dati. 
\vspace{1ex} \newline 
Siccome il collo di bottiglia risultava il valore che lo stesso byte aveva, si è pensato di ridurre
%la distanza associata ai vari possibili dati 
i dati trasmissibili riducendo i valori ASCII usati nella trasmisisone; 
in particoalre si sarebbero inviati solo i caratteri stampabili. 
La scelta è stata ritenuta valida siccome nella codifica ASCII i principali 
caratteri stampabili vanno da 32 sino a 126 [Tabella \ref{tabella:ASCII:table}]. 
Tuttavia ciò, oltre ad aggiungere overhead inutile, avrebbe tagliato fuori alcuni caratteri 
speciali come il tab o il carattere di nuova linea. 
%Di conseguenza caratteri speciali come \\n o \\t non sarebbero potuti essere inviati. 
Inoltre il metodo sarebbe stato vincolato alla codifica ASCII. 
Quindi se i dati fossero stati codificati tramite un altro metodo, si sarebbero potuti tagliare dati importanti.  
\begin{center} 
\begin{longtable}{|p{0.25\textwidth}|p{0.55\textwidth}|} 
    \hline
    \textbf{Range} & \textbf{Descrizione} \\
    \hline
    \textbf{Control Character} [0-31] &  
    %The first 32 characters in the ASCII-table are unprintable control codes and are used to control peripherals such as printers. 
    Codici di controllo non stampabili e che vengono utilizzati per controllare le periferiche. \\ %(come le stampanti). \\
    \hline 
    \textbf{Printable character} [32-127] & 
    %Codes 32-127 are common for all the different variations of the ASCII table, they are called printable characters, represent 
    %letters, digits, punctuation marks, and a few miscellaneous symbols. You will find almost every character on your keyboard. 
    %Character 127 represents the command DEL. 
    Rappresentano lettere, cifre, segni di punteggiatura e vari simboli. \\ 
    \hline 
    \textbf{Extended ASCII Codes} [128-255] & 
    %There are several different variations of the 8-bit ASCII table. 
    %I valori fra 128 a 255 
    Non fanno parte dell'ASCII standard ma alla sua versione estesa. 
    I caratteri presenti dipendono dalla codifica utilizzata. 
    %La più comune è ISO 8859-1 (chiamata anche ISO Latin-1). 
    \\  
    \hline 
\caption{Struttura della tabella ASCII} 
\label{tabella:ASCII:table} 
\end{longtable} 
\end{center} 
Quindi si è definita una funzione che cercerà di normalizzare l'intervallo 
di tempo, associato al dato, fra un valore minimo e uno massimo \cite{time_normalization1} \cite{time_normalization2} \cite{time_normalization3}. 
Tramite questa funzione il range dei possibili delay è stato ristretto a due valori precisi e 
definiti che permetterà di inviare un maggiore numero di informazioni in un tempo minore [Figura \ref{fig:covertTiming:intervalli:normalizzazione} ].
%E questo ha permesso l'invio di 72 byte in circa 13/14 minuti. 
\vspace{2ex} \newline
Il lato negativo è una maggiore possibilità di errore. %se il computer che riceve i dati subisce un delay, 
In questo caso bisongerà impostare correttamente il valore minimo e massimo affinche i dati 
vengano decodificati in maniera errata.  
Minore è la loro differenza maggiore sarà la probabilità che i ritardi influenzino il risultato. 
%di decodificare il carattere sbagliato.  
%maggiore rispetto ai metodi che implementavano una distanz adi sicurezza. 
\begin{equation}
    \text{min\_delay}+(\text{byte}/255)*(\text{max\_delay}-\text{min\_delay})
\end{equation} 
\label{equation:2:tempi:timingCC} 
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=0.45\textwidth]{./img/timing_channel/timinmg_channel_2nd_function.png}
    \captionof{figure}{Normalizzazione degli intervalli (Timing Channel) \cite{time_normalization4}} 
    \label{fig:covertTiming:intervalli:normalizzazione} 
\end{minipage} 
%
\subsubsection{Randomizzazione dei tempi di invio dei pacchetti} 
Siccome si mandano i pacchetti con tempi costanti si sviluppa il Covert Channel inserendo del rumore. 
Il tempo di delay associato a un byte non sarà più costante ma spazierà fra un range di valori, 
nel quale potrà variare [Figura \ref{fig:covertTiming:intervalli:casuali} ]. 
%tempo di delay non sarà più un tempo costante fra un pacchetto e il successivo. 
%Quindi invece di aspettare un tempo costante per lo stesso carattere. 
%Siccome la quantità di rumore aggiunta dovrà risultare casuale, si è definito un range di tempo nel quale può variare.  
%dipenderà in un determinato range di tempo. %di tempo associato in cui il carattere può variare. 
Ciò è necessario siccome gli IDS riescono ad individuare gli schemi temporali, 
%si è definito un range così da poter mandare tempi randomici e non costanti. 
quindi poter avere uno schema che sembri randomico, permetterà di non essere rilevati. 
%\vspace{2ex} \newline 
%Ora la codifica di un byte, non è più definita da un singolo, costante e prevedibile intervallo di tempo, 
%ma da un range di intervalli temporali. %che continuamente cambiano.    
\newline 
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./img/timing_channel/timinmg_channel_rumore.png}
    \captionof{figure}{Randomizzazione dei tempi con il rumore (Timing Channel)} 
    \label{fig:covertTiming:intervalli:casuali} 
\end{minipage} 
\vspace{2ex} \newline
Per potersi scambiare i dati, il mittente e il destinatario devono potersi sincronizzare sulla 
quantità di rumore che si è aggiunto. Le strade possibili sono due: 
\begin{enumerate} 
    \item Ogni entità crea un numero randomico e si dovranno sincronizzare sul seed usato oltre 
    al numero di estrazioni effettuate. Se i valori estratti non combaciassero; 
    le entità non riusciranno a scambiarsi i dati correttamente. 
    \item Il mittente indica il rumore generato nel pacchetto stesso (tramite uno dei campi o il payload). 
    Il ricevente otterrà il valore generato dalla risorsa condivisa. 
    Tuttavia in questo caso sarebbe maggiormente comodo inserire il dato direttamente nel campo. 
    \item Il tempo non trasporterà alcun dato negli intervalli di tempo. 
    Ma in questo caso non si tratterà più di un Timing Covert Channel. 
\end{enumerate} 

\subsubsection{Requisiti per la comunicazione} 
Siccome il destinatario rimane in ascolto e, all'arrivo di un pacchetto, ricava il dato associato 
all'intervallo di tempo; avrà bisogno di un messaggio che indichi quando la trasmissione inizia. 
Il mittente dovrà quindi mandare un pacchetto per indicare la cosa prima di iniziare la comunicazione. 
\vspace{1ex} \newline 
Questo datagram potrà essere un pacchetto contenente un valore specifico oppure di un tipo specifico. 
%Questo serve e impostare il tempo di inizio; 
%se non lo si determina, il destinatario all'inizio non riuscirà a calcoalre l'intervallo di tempo fra il pacchetto corrente e quello precedente. 
%E quindi non si riuscirà a decodificare il primo bit. 
%
%Dopodichè si manda un pacchetto per inizializzare il tempo del ricevente e si procede con il ciclo. 
%Successivamente si itererà l'intera lista contenente i singoli bit e si aspetterà il tempo associato. 
%\vspace{4ex} \newline 