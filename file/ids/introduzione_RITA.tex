%https://github.com/activecm/rita 
%https://www.activecountermeasures.com/free-tools/rita/ 
%https://www.promptzine.com/threat-hunting-zine/rita-real-intelligence-threat-analytics 
%https://www.youtube.com/watch?v=kwR3TjIgoCo&t=13s 


%UNUSED
%https://www.activecountermeasures.com/intro-to-rita-v5/


\section{RITA} 
\subsection{Cos'è RITA} 
RITA is an open-source network threat hunting tool designed to identify malicious command and control (C2) activity. 
It ingests Zeek connection logs and uses behavioral analytics to identify potentially compromised systems. 

Real Intelligence Threat Analytics (R-I-T-A) is an open-source framework for detecting command and control communication through network traffic analysis. 
The RITA framework ingests Zeek logs in TSV or JSON format, or PCAPs converted to Zeek logs for analysis. 

There is often a massive disconnect between what attackers are doing and what we, as defenders, are doing to detect them. 
There is currently a huge push to develop better and better Indicators of Compromise (IOC) or better threat intelligence.
A newer development in information security is hunt teaming. 
This is where an organization has a team of individuals who actively go looking for evil on a network. 
This makes some significant assumptions on the part of the defenders. 
The first assumption is that security automation has failed somewhere. 
The second assumption is that the existing technologies will not be sufficient to find the bad guys.


For example, one of Black Hills Information Security’s tools is called VSagent. 
It hides its Command and Control (C2) traffic into the “__VIEWSTATE” parameter, which is base64 encoded. 
Further, it beacons every 30 seconds.
Unfortunately, the ideas of this backdoor can be easily modified to bypass any simple signature you throw at it.
How then, exactly, can we approach malware like this? It requires us not to look at individual TCP streams but rather at the communication related to much larger timeframes.


There are several different frameworks for Pentesting, such as Metasploit, SET, and Recon-ng. 
The idea of a framework is that it is effective, extensible, and allows people in the InfoSec community to add additional modules to it continuously is our goal.


Primary Features
    Beacon Detection: Search for signs of beaconing behavior in and out of your network
    DNS Tunneling Detection: Identify signs of DNS-based covert channels
    Long Connection Detection: Easily see connections that have communicated for long periods of time
    Threat Intel Feed Checking: Query threat intel feeds to search for suspicious domains and hosts
    Connections Scored by Severity: Critical, High, Medium, Low
    Prevalence: Displays how many of your internal hosts are communicating with a particular external host
    First Seen: Displays when the external host was first seen on the network

\subsection{What's the purpose of Threat Hunting} 
Perimeter defensive tools like firewalls and IDS protect your valuable systems. 
A solid incident response plan allows your team to contain and eliminate a discovered threat

But how do we identify when your protective layers have failed and incident response is needed? 
What happens when an attacker is already inside? It is clear from the evidence that preventative and reactive measures are woefully insufficient. 
The average time to identify and contain a data breach has remained virtually unchanged for the past seven years — a shocking figure considering the average cost. 
And needless to say that while the financial consequences are significant, the final impact surpasses it. 
Loss of personal information has impacted millions of people, and rising breaches in the healthcare and critical infrastructure industries have placed vital services at risk of failure.

The one absolute constant we, as threat hunters, can rely on is that malware must call home. 
By analyzing network traffic, we can detect C2 calling home regardless of platform and without the need of endpoint agents. 
Unfortunately, scouring through log data by hand and reading individual connection entries is unlikely to alert you to potential C2 activity. 
For better fidelity, behavior and pattern analysis needs to look at the communication between an internal and external host over time. 
Persistency is the key attribute we look for when searching for compromised systems. 
RITA looks for the primary indicators of this persistency, allowing you to focus on vetting the activities flagged by its findings.

RITA’s analysis stage splits these primary indicators of persistency into separate modules, allowing results to be viewed based on a specific indicator. 
Let’s look at some of the main modules that make up this analysis. 

\subsubsection{Beacons} 
Beacons are repeating “heartbeat” communications between a pair of hosts. 
While some beacons are innocuous, a compromised system will use beaconing to continuously request instructions or exfiltrate data, allowing an attacker to maintain a persistent presence on the network. 
RITA identifies and scores four different types of beacons. 
We recommend investigating hosts with scores over 85\% to verify that the associated network traffic fulfills a legitimate business need.

\subsubsection{IP} 
An IP beacon may indicate that a compromised internal system is communicating with a C2 server at a specific IP address. 
This module analyzes connections between an internal source IP and an external destination IP pair. 
\begin{lstlisting}
$ rita show-beacons
\end{lstlisting}

\subsubsection{Web} 
Web beacons are cases where an internal host communicates with a C2 server through a CDN. 
The CDN will spread out the C2 traffic over multiple IPs and mix it in with legitimate traffic. 
RITA reverses this process to make C2 connections clearly visible.
\begin{lstlisting} 
$ rita show-beacons-sni
\end{lstlisting}

\subsubsection{Proxy } 
Environments that use one or more proxy servers for external communication may struggle to identify beacons due to the proxy server appearing as the destination of an HTTP/HTTPS request. 
This module uses Proxy CONNECT header information to determine the originally requested destination for its beacon analysis.
\begin{lstlisting} 
$ rita show-beacons-proxy
\end{lstlisting}

\subsubsection{Strobes} 
Internal to external host pairs that trigger a new connection one or more times per second are called strobes. 
Since these are indisputable beacons based on the frequency of communication alone, they are not scored and instead presented as a list sorted on connection count.
\begin{lstlisting} 
$ rita show-strobes
\end{lstlisting}

\subsubsection{Scoring Breakdown} 
The score of each beacon is determined by four factors.
Timestamp Analysis - Time interval consistency between sessions.
Datasize Analysis - Size consistency between sessions
Histogram Analysis - Frequency of sessions over time
Duration Analysis - Persistency of channel within timeframe

\subsubsection{Exploded DNS} 
A compromised system may leverage DNS to set up a C2 channel by encoding data in the FQDN or query portion of a DNS request. 
To avoid DNS caching and ensure that the local resolver forwards the request, the malware will use a unique query for every request by varying the FQDN. 
This results in thousands of separate resource requests to a single parent domain. 
This module displays the unique FQDN count and total DNS lookups for each domain. 
\begin{lstlisting} 
$ rita show-exploded-dns
\end{lstlisting}

\subsubsection{Long Connections} 
Long connections can be an indicator of well-established malware, allowing a compromised system to receive commands and exfiltrate data without constantly checking in with the C2 server. 
Longer sessions also create fewer log entries, making them difficult to detect. 
This module displays a sorted list of the longest connections and their source and destination hosts.
\begin{lstlisting} 
$ rita show-long-connections
\end{lstlisting}

\subsubsection{User Agent} 
User agent strings can also function as indicators of compromise. 
Malware might use a weird or uncommon user agent string or alter one to make it appear as if it was coming from a browser or client other than the one infected. 
Detecting and vetting such irregularities can assist you in determining whether a communication is malicious or benign. 
This module displays a list of unique user agent strings found in the dataset.
\begin{lstlisting} 
$ rita show-useragents
\end{lstlisting}

\subsubsection{Threat Intel} 
Threat intelligence feeds contain information on potentially malicious hosts based on attack information accumulated through various sources. 
You can customize which feeds this module uses in its analysis. 
Results display a list of the potentially malicious matches split into three categories: hostnames, IPs contacted via an outbound connection, and IPs that initiated an inbound connection.
\begin{lstlisting} 
$ rita show-bl-dest-ips 
$ rita show-bl-source-ips 
$ rita show-bl-hostnames 
\end{lstlisting}

\subsubsection{Tips and Tricks} 
Format module results into easy-to-read tables by adding -H to the command:
\begin{lstlisting} 
$ rita show-strobes <dataset> -H
\end{lstlisting} 
Create a simple HTML summary of all module results:
\begin{lstlisting} 
$ rita html-report <dataset>
\end{lstlisting} 
You can filter results of any module by using grep. 
One example is to create a text file with the IP addresses to exclude (one per line) and use it when piping into grep:
\begin{lstlisting} 
$ rita show-beacons <dataset> | grep -v -w -F -f <filename>
\end{lstlisting} 
If you find a suspicious result, you can use your Zeek logs to gather more context clues about the hosts or connections. 
Check out the Useful Threat Hunting Scripts article for some examples.
Most modules have thresholds that can be adjusted via RITA’s configuration file. 
The beacon modules also allow you to customize the weight each subscore (see Score Breakdown in Beacons section) has on the final score. 


\subsection{How to Install RITA} 
The package can be found at https://github.com/activecm/rita/releases . You’ll need to launch the installer from a Linux system, and from there you can push out RITA to any of the above Linux distributions.

In a command prompt (found under the “Terminal” application if you’ve installed a Desktop), run the following to install RITA on this system:
\begin{lstlisting}
cd
wget https://github.com/activecm/rita/releases/download/v5.0.0-beta/rita-v5.0.0-beta.tar.gz
tar -xzvf rita-v5.0.0-beta.tar.gz
cd rita-v5.0.0-beta-installer
./install_rita.sh localhost
\end{lstlisting}
You’ll be asked for your user’s password a few times.

\subsection{How to Install Zeek}
Zeek used to be installed automatically when installing RITA – it’s now part of the “docker-zeek” package. To use that to install Zeek, run the following commands on the target Linux system after installing RITA. Note that the “sudo wget…” command wraps onto two lines below, but it needs to be one typed line with a space just before “https”:
\begin{lstlisting}
sudo wget -O /usr/local/bin/zeek https://raw.githubusercontent.com/activecm/docker-zeek/master/zeek
sudo chmod +x /usr/local/bin/zeek
zeek start
\end{lstlisting}
We encourage you to install docker-zeek on a physical system but RITA can be installed on a physical or virtual machine. 
%https://www.activecountermeasures.com/is-it-ok-to-capture-packets-in-a-virtual-machine/





