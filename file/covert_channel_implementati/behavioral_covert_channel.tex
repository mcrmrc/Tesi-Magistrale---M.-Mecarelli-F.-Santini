%I canali nascosti comportamentali operano estraendo 
Le informazioni vengono codificate modificando il comportamento del sitema. 
Quindi i dati vengono ricavati osservando il comportamento del sistema 
%durante l'esecuzione di operazioni, 
piuttosto che attraverso l'accesso diretto ai dati.
%La trasmissione dei dati avviene quindi in base ai diversi eventi che avvengono e 
%generalmente suddividendo e trasmettendo i dati in pacchetti più piccoli. 
%Operano quindi trasmettendo dati in base all'avvenimento di diversi eventi. 
%di processi, sistemi e applicazioni, generalmente suddividendo e trasmettendo i dati in pacchetti più piccoli. 
\vspace{2ex} \newline 
In questo caso l'evento che si osserverà è la tipologia ed il codice del messaggio ICMP che è arrivato. 
%Siccome oltre alla tipologia si potrà variare il codice inviato; 
Di condesguenza la quantità di eventi inviabili risulta 17. 
E quindoi ogni messaggio permetterà di codificare 4 bit alla volta (siccome $\log_216=4$). 
La tipologia inutilizzata, verrà sfruttata per indicare l'inizio e la fine della comunicaizone. 
\vspace{1ex} \newline
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./img/timing_channel/behavioural_channel_1.png}
    \captionof{figure}{Schema Hybrid Channel} 
\end{minipage}  
\vspace{1ex} \newline 
In questo caso si maschererà il byte così da dividerlo in due parti. %mascherando il suo valore. %binario. 
Ogni 4 bit 
%quattro bit ricavati, e dagli ultimi quattro bit, 
determinano la tipologie e il codice che il messaggio da inviare dovrà avere. 
\vspace{1ex} \newline
\begin{lstlisting}
    primi_4bit=(numero& 0b11110000)>>4
    ultimi_4bit=numero& 0b00001111  

    bit_codice={}
    lista_codici=[
        30,31,32,33,34,35 #destination unreachable
        ,110,111 #time exceeded
        ,120 #parameter problem
        ,40 #source quench
        ,50,51,52,53 #redirect
        ,80#, 0 #echo request/reply
        ,130#, 140 #timestamp request/reply
        ,150#, 160 #info request/reply
    ] 
    for index in range(0,len(lista_codici)):
        bit_codice.update({index:lista_codici[index]})

    #messaggio=[codice,tipologia]
    primo_messaggio=[
         bit_codice[primi_4bit]%10
        ,bit_codice[primi_4bit]//10
    ]  
    secondo_messaggio=[
         bit_codice[ultimi_4bit]%10
        ,bit_codice[ultimi_4bit]//10
    ] 
\end{lstlisting}  
\caption{Estrazione dal byte il Codice e Tipologia per il messaggio} 
\label{lstlisting:behavioral:estrazioneCodiceTipologia} 
%\vspace{2ex} \newline 
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=0.7\textwidth]{./img/hybrid_channel/wireshark_hybridChannel.png}
    \captionof{figure}{Flusso di un Covert Channel Comportamentale} 
\end{minipage} 
\vspace{2ex} \newline
Il destinatario monitora il traffico di rete e controllerà le tipologie di messaggi ICMP provenienti. 
Da ogni coppia (Tipologia, Codice) ricaverà quatttro bit. 
%invece si metterà in ascolto nel traffico di rete di un messaggio \textit{Information Request} 
%proveniente dall'attaccante. 
%Una volta ricevuto, memorizzerà le tipologie di messaggi ICMP provenienti dalla sorgente e 
%ogni volta ricava il byte associato alla coppia di messaggi ottenuta. 
%Infine quando rileverà ancora un pacchetto \textit{Information Request} smetterà di monitorare la rete. 
\vspace{1ex} \newline
\begin{lstlisting}
previous_type=prev_pkt[ICMP].type*10+prev_pkt[ICMP].code
current_type=curr_pkt[ICMP].type*10+curr_pkt[ICMP].code

codice_bit={}
lista_codici=[
    30,31,32,33,34,35 #destination unreachable
    ,110,111 #time exceeded
    ,120 #parameter problem
    ,40 #source quench
    ,50,51,52,53 #redirect
    ,80#, 0 #echo request/reply
    ,130#, 140 #timestamp request/reply
    ,150#, 160 #info request/reply
] 
for index in range(0,len(lista_codici)):
    codice_bit.update({lista_codici[index]:index}) 

previous_bit=codice_bit[previous_type] 
current_bit=codice_bit[current_type] 
byte=(previous_bit<<4)+current_bit
\end{lstlisting}  
\caption{Estrazione dai messaggi il byte del dato} 
\label{lstlisting:behavioral:estrazioneByte} 



\subsection{Hybrid Covert Channel} %(Ibrido)
Partendo dalle versioni precedenti dei Covert Channel sviluppati; 
si può implementare una versione che le combina. 
%Dopo aver analizzato, studiato ed implementato varie tipologie di Covert Channel; 
%procediamo nello sviluppare una loro versione ibrida. 
\begin{itemize}
    \item Da un byte verrà ricavato il delay fra un pacchetto e l'altro. (Timing Channel)
    %Questa versione invieerà un messaggio dopo un determinato intervallo di tempo; ricavato dalla codifica del byte presente nei dati. 
    \item Da un byte verranno ricavate le due tipologie di messaggi da mandare. (Behavioural Channel)
    %Dopodichè, ricaverà un ulteriore byte e da esso ricaverà la coppia di messaggi che determinano la sua codifica. 
    \item In ciascun pacchetto verranno inseriti tanti dati quanto la capacità di trasmissione del messaggio. (Storage Channel) 
    %In ciascuno di questi messaggi verranno nascoste delle porzioni di dati aggiuntive. 
\end{itemize}
\begin{lstlisting} [language=Python, showspaces=false, showstringspaces=false, showtabs=false]
    dato="Dato da inviare"
    index=0 
    while index < len(dato)
        byte_1=dato[index] 
        index+=1
        delay=getDelay(byte_1) 
        wait(delay) 

        byte_2=dato[index] 
        index+=1
        primi_4bit=(byte_2 & 0b11110000)>>4
        ultimi_4bit=byte_2 & 0b00001111 

        for bit in [primi_4bit, ultimi_4bit]: 
            tipologia_msg=getTipologia(bit)
            capacita_msg=getCapacita(tipologia_msg) 
            data_msg=data[index:index+capacita_msg]
            packet=getPacket(tipologia_msg, data_msg) 
            index+=capacita_msg
            send(packet) 
\end{lstlisting} 
\captionof{lstlisting}{Pseudocodice per l'invio dei dati con Hybrid Covert Channel} 
\label{lstlisting:codice:hybridchannel:mittente}
%\begin{center}
%    \begin{tabular}{|c|c|} 
%        \hline
%        \textbf{Messaggio ICMP} & \textbf{Dati trasportabili} \\ 
%        \hline
%        Information Request (15-16) & 2 byte \\ 
%        \hline
%        Timestamp Request (13-14) & 5 byte  \\ 
%        \hline 
%        Echo Request (8-0) & 2 byte  \\ 
%        \hline
%        Redirect (5) & 4 byte  \\ 
%        \hline
%        Source Quench (4) & 8 byte  \\ 
%        \hline
%        Parameter Problem (12) & 7 byte  \\ 
%        \hline 
%        Time Exceeded (11) & 6 byte  \\ 
%        \hline
%        Destination Unreachable (3) & 8 byte  \\ 
%        \hline 
%    \end{tabular} 
%    \captionof{table}{Quantità di byte trasportabili da un messaggio} 
%    \label{table:messaggiICMP:byte}
%\end{center}
\vspace{2ex} 
%Quindi il mittente avrà una sequenza di dati da inviare. 
%Da essa ricaverà il primo byte e ricaverà il suo intervallo di tempo. 
%Successivamente prenderà un ultriore byte e lo dividerà in due parti ognuna di 4 bit. 
%ciascuna parte identificherà una tipologia di messaggio. 
%In base ai messaggi ircavati al loro interno codificherà tanti dati quanto la loro capacità. 
%\vspace{3ex}  \newline
%Il destinatario invece monitora il flusso dei dati nella rete per rilevare un 
La comunicazione viene iniziata tramite un messaggio \textit{Information Request} e chiusa sempre da un messaggio dello stesso tipo. 
Una volta aperta, si ricaverà l'intervallo di tempo con cui arrivano le coppie di messaggi e da questo si ricaverà un byte. 
Per ogni messaggio presente nella coppia, vengono ricavati i quattro bit associati alla tipologia eal codice del pacchetto in questione. 
Una volto uniti tutti i bit, in base all'ordine di arrivo dei due pacchetti, si oterrà un byte. 
%Arrivata la coppia di messaggi e ricavata la loro tipologia, oterrà un ulteriore byte definito dalla codifica della coppia di messaggi. 
Infine si ricaveranno i dati che sono stati nascosti nei campi del messaggio ICMP. 
%Infine ricaverà i dati nasocsti nei due messaggi. 
%Il ricevente continuerà in questo modo finchè non riceverà un secondo messaggio di tipo \textit{Information Request}; 
%in quel caso la connessione è chiusa e si può terminare di monitoprare il traffico di rete.
\vspace{1ex} \newline 
\begin{lstlisting} [language=Python, showspaces=false, showstringspaces=false, showtabs=false]
isSending=False 
tempo_precedente=None
tempo_corrente=None 
received_packet=0
tipologia_prima=None

data=[]

def wait_packet(pacchetto): 
    if pacchetto.tipologia =="Information Request": 
        if not isSending: 
            print("Primo Information Request")
            isSending= not isSending 
            tempo_precedente=pacchetto.time
            tempo_corrente=pacchetto.time 
        else: 
            print("Secondo Information Request")
            exit()
    if not isSending:
        return
    received_packet=(received_packet+1)%2  
    if received_packet==1: 
        print("Primo pacchetto")
        tipologia_prima=pacchetto.tipologia
        tempo_corrente=pacchetto.time 
        delta=tempo_corrente-tempo_precedente 
        tempo_precedente=tempo_corrente
        data.append(getTimeData(delta)) 
    elif received_packet==0: 
        print("Secondo pacchetto")
        tipologia_ora=pacchetto.tipologia
        data.append(
            getBehaveData(tipologia_ora, tipologia_prima)
        ) 
    data.append(getStorageData(pacchetto))

\end{lstlisting} 
\captionof{lstlisting}{Pseudocodice per ricezione dei dati con Hybrid Covert Channel} 
\label{lstlisting:codice:hybridchannel:destinatario} 
\vspace{2ex}  
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=0.6\textwidth]{./img/hybrid_channel/sender_hybridChannel_1.png}
    \captionof{figure}{Invio dei dait tramite Hybrid Covert Channel} 
\end{minipage} 
\vspace{3ex} \newline
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=0.6\textwidth]{./img/hybrid_channel/receiver_hybridChannel.jpg}
    \captionof{figure}{Ricezione dei dait tramite Hybrid Covert Channel} 
\end{minipage} 