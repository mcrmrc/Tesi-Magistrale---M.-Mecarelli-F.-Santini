%I covert channel di temporizzazione sono metodi di comunicazione che permettono ad un osservatore 
%(un umano o un processo) di acquisire 
%informazioni attraverso il cambiamento del tempo di risposta di una risorsa. 
%Sfruttando gli intervalli di tempo o l'ordine degli eventi per codificare informazioni (e.g. ritardi fra i pacchetti di rete,\dots). 
%Qualsiasi metodo che utilizza un orologio (o una misurazione del tempo) per segnalare il valore può implementarlo.
%\begin{esempio}
%        Modificare i permessi dei file o i metadati per codificare informazioni oppure modificare variabili condivise o buffer.
%    \end{esempio}
%\href{https://www.youtube.com/watch?v=QIvsmQQ6vu8}{Video Esempio} 


%I covert channel di temporizzazione sono metodi di comunicazione che permettono ad un osservatore (un umano o un processo) di acquisire informazioni attraverso il cambiamento del tempo di rispostadi una risorsa. 
Sfruttano gli intervalli di tempo o l'ordine degli eventi per codificare le informazioni (e.g. ritardi fra i pacchetti di rete,\dots). 
Qualsiasi metodo che utilizza un orologio (o una misurazione del tempo) per segnalare il valore può implementarlo. 
\vspace{2ex} \newline
Per la \textbf{codifica}, si ricava il delay associato al dato e successivamente si apetta l'intervallo di tempo ricavato. 
%Per implementarli sarà quindi presente un metodo di codifica, usato dal mittente, che ricaverà il tempo associato ad un dato e poi aspetterà tale intervallo di tempo. 
%Per esempio se al dato binario 1001 fosse associato il tempo 3, il programma prima leggerà il dato e poi aspetterà tre secondi. 
\begin{lstlisting} [language=Python, showspaces=false, showstringspaces=false, showtabs=false]
with open("path","r) as read_file:
    for data in read_file.read(): 
        delay=getDelay(data)
        wait(delay)
\end{lstlisting}
\captionof{lstlisting}{Pseudocodice per la codifica (Timing Covert Channel)} %dei dati in intervalli di tempo
\label{lstlisting:pseudocodice:timingChannel:code} 
\vspace{4ex}  
Invece per la \textbf{decodifica}; il destinatario calcolerà l'intervallo di tempo fra un pacchetto e l'altro, e da quello ricaverà il dato che gli è associato. 
%Invece per ricevere le informazioni, il destinatario rimane in attesa dei pacchetti che gli verranno inviati. 
%Successivamente ricaverà l'intervallo di tempo fra il pacchetto precedente e quello corrente e poi ricaverà il valore associato. 
%Per esempio se l'intervallo di tempo risultassedi 6 secondi, il destinatario controllerà a chi è associato tale tempo (in questo caso diciamo il dato binario 1101). 
\begin{lstlisting} [language=Python, showspaces=false, showstringspaces=false, showtabs=false]
tempoPrecedente=None 
def wait_packet(pacchetto): 
    if not tempoPrecedente: 
        tempoCorrente=pacchetto.time
        tempoPrecedente=pacchetto.time
        return
    tempoCorrente=pacchetto.time 
    deltaTempo=tempoCorrente-tempoPrecedente
    data=getData(deltaTempo) 
    tempoPrecedente= tempoCorrente 
\end{lstlisting}
\captionof{lstlisting}{Pseudocodice per la decodifica (Timing Covert Channel)} %dei dati dagli intervalli di tempo
\label{lstlisting:pseudocodice:timingChannel:decode}

%\subsubsection{Covert Channel Temporale tramite pacchetti ICMP Echo} 
\subsubsection{Prima implementazione}
%In questo caso si definisce un Covert Channel Temporale inviando pacchetti ICMP (di tipo Echo) in intervalli specifici. 
%Tramite la differenza fra il tempo precedente e il tempo di ircezione del nuovo pacchetto; 
%l'attaccante riuscirà a codificare un bit (o coppie di bit) mentre la vittima riuscirà a decodificare il bit (o la coppia di bit) associato all'intervallo. 
%\vspace{1ex} \newline 
%Siccome deve essere presente una maniera 
Per poter codificare e decodificare i tempi da associare ai dati, in un primo momento si è definita la seguente funzione: 
%La formula per calcolare i tempi associati alle codifiche dei bit è la seguente: \newline
\begin{equation}
    %\text{tempo\_base}+\text{indice}*(2*\text{distanza\_tempi})
    \text{tempo\_base}+\text{indice}*\text{distanza\_tempi}
\end{equation}
\label{equation:1:tempi:timingCC}
%\begin{lstlisting}
%DISTANZA_TEMPI=2 #sec 
%TEMPI_CODICI=[3+index*2*DISTANZA_TEMPI for index in range(2**2)] #00, 01, 10, 11 
%TEMPO_BYTE=0*60 #minuti
%\end{lstlisting} 
%\captionof{lstlisting}{heading} 
%Si definisce un \textbf{tempo di base} di \textit{3 secondi} e una \textbf{distanza} minima che tutti i tempi dovranno avere. 
%In questo caso si è deciso che la distanza sia di almeno \textit{2 secondi}. 
\begin{center} 
\begin{longtable}{|p{0.25\textwidth}|p{0.55\textwidth}|} 
    \hline
    \textbf{Parametro} & \textbf{Descrizione} \\
    \hline
    \textbf{Tempo di base} &  
    Il minimo di secondi che si dovrà aspettare per ciascun possibile dato. \\
    \hline 
    \textbf{Distanza fra i tempi} & 
    Distanza minima di tempo che tutte le codifiche dovranno avere fra di loro. 
    Lo scopo è evitare che i tempi relativi a due codifiche si sovrappongano. \\
    %In quei casi la decodifica potrà essere erronea. \\ 
    \hline 
    \textbf{Indice} & 
    Indica l'indice associato alla codifica del dato. 
    Il suo valore và da 0 sino al masismo numero di codifiche possibili per i dati. \\ 
    %Siccome si trattano bit, corrisponderà all'intero rappresentato dalla coppia di bit (eg 101=5). 
    \hline 
\caption{Parametri della prima funzione (Timing Channel)} 
\label{tabella:timingCC:parametri:funzione1} 
\end{longtable} 
\end{center} 
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./img/timing_channel/timing_channel_times_nonoverlapping.png}
    \captionof{figure}{1a funzione: assegnazione degli intervalli con la distanza} %di tempo 
\end{minipage} 
\begin{minipage}{\textwidth}
    \includegraphics[width=\textwidth]{./img/timing_channel/timing_channel_times_overlapping.png}
    \captionof{figure}{1a funzione: assegnazione degli intervalli senza la distanza}  %di tempo 
\end{minipage} 
\vspace{1ex} \newline 
Se mai nel sistema avvenissero dei ritardi data la latenza della rete unn intervallo di tempo potrebbe codificare il dato sbagliato. 
Infatti il tempo in cui la destinazione riceverà il messaggio è dato dal delay per codificare il dato più il ritardo di rete. 
In generale il valore di questo parametro dipenderà dall'ubicazione geografica dell'entità mittente e di quella destinataria, 
oltre alla reattività delle due macchine. 
\vspace{1ex} \newline
%AAA: \href{https://learn.microsoft.com/en-us/azure/networking/azure-network-latency?tabs=Americas%2CWestUS}{text}
%https://andrewpakhomov.com/posts/latency-tail-latency-and-response-time-in-distributed-systems/
%https://www.kentik.com/kentipedia/network-latency-understanding-impacts-on-network-performance/
%
\begin{minipage}{\textwidth}
    \includegraphics[width=\textwidth]{./img/timing_channel/timinmg_channel_network_latency.png}
    \captionof{figure}{Schema latenza nel sistema} 
\end{minipage} 
%\vspace{1ex} \newline 
%Quindi, siccome si sta lavorando a livello di bit, dal dato %da inviare (di qualunque tipo esso sia) 
%dovrà essere convertito in una lista di byte, dalla quale 
%estrarremo i singoli bit che poi manderemo, codificandoli tramite l'intervallo di tempo associato. 
%Nel frattempo il destinatario rimarrà in ascolto e all'arrivo di un pacchetto calcolerà l'intervallo di tempo trascorso e 
%ricaverà il dato associato ad esso. 
%\vspace{1ex} \newline
%\textbf{NB} all'inizio si manderà un pacchetto per indicare al destinatario l'inizio della comunicazione. 
%Questo serve e impostare il tempo di inizio; 
%se non lo si determina, il destinatario all'inizio non riuscirà a calcoalre l'intervallo di tempo fra il pacchetto corrente e quello precedente. 
%E quindi non si riuscirà a decodificare il primo bit. 
%
%Dopodichè si manda un pacchetto per inizializzare il tempo del ricevente e si procede con il ciclo. 
%Successivamente si itererà l'intera lista contenente i singoli bit e si aspetterà il tempo associato. 
%\vspace{4ex} \newline 
%Questo metodo di codifica risulterà poco pratico. 
%come si può vedere dalla tabella, risulterà maggiormente conveniente mandare un numero minore di dati siccome una codifica maggiore richeiderà un tempo maggiore. 
%Alla fine risulterà che conviene di più inviare 2 bit rispetto che 4 bit. 
%Tuttavia il numero di bit inviatirisulterà non sufficente. 
%\begin{center}
%    \begin{tabular}{|c|c|c|}
%        \hline
%        \textbf{Num bit} & \textbf{IPv4} & \textbf{IPv6} \\ 
%        \hline
%        1 & 8:33  & 14:46 \\ 
%        \hline
%        2 & 7:20  & 12:08 \\ 
%        \hline
%        4 & 12:00 & 22:20 \\ 
%        \hline
%    \end{tabular} 
%    \captionof{table}{Tempi di esecuzione del Timing Channel}
%    \label{table:tempi:esecuzione:timingCC}
%\end{center} 

%\subsubsection{Timing Channel a 8 bit} 
\subsubsection{Seconda implementazione} 
Uno secondo sviluppo effettuato è stato per l'ampliamento dei dati trasportabili. 
Nella prima versione i tempi di attesa per inviare i dati risultavano eccessivamente lunghi. 
Oer migliorare questo aspetto, si è preso spunto dall'approccio implementato in ICMP Exfill: 
in esso il delay da aspettare viene determinato dal valore del byte che si vuole inviare. 
ciò è possibile siccome in memoria rappresenta una sequenza di bit che può essere interpretata come un numero intero.
L'intervallo di tempo verrà quindi ricavato dall'intero associato al byte da codificare. 
%viene quindi ricavato convertendo in un intero la rappresentazione in memoria dei bit presenti. 
%Il byte rappresentante il carattere, verrà quindi letto come un numero intero ed usato per determinar il tempo di delay. 
\vspace{1ex} \newline 
Tuttavia una semplice conversione risulta inefficace siccome il tempo minimo di attessa risultava zero mentre il delay masismo in alcunicasi potrà essere 255 secondi. 
Inizialmente si è optato per sottrarre al numero ricavato un certo valore, questa sceltaè stata dettata dal fatto che i caratteri 
stampabili nella codifica ASCII hanno un range ben definito. 
%Il valore in questione era 31 siccome i caratteri stampabili vanno da 32 sino a 127. 
%Ma anche qui l'ostacolo era la presenta di caratteri speciali che così sarebbero stati tagliati fuori. 
%Di conseguenza caratteri speciali come \\n o \\t non sarebbero potuti essere inviati. 
Tuttavia ciò avrebbe tagliato fuori alcuni caratteri speciali come il tab o il carattere che indica una nuova linea. 
Inoltre avrebbe vincolato l'approccio solo alla codifica ASCII e quindi avrebbe portato a un metodo per codifica dei caratteri presenti. 
\begin{center} 
\begin{longtable}{|p{0.25\textwidth}|p{0.55\textwidth}|} 
    \hline
    \textbf{Range} & \textbf{Descrizione} \\
    \hline
    \textbf{Control Character} [0-31] &  
    %The first 32 characters in the ASCII-table are unprintable control codes and are used to control peripherals such as printers. 
    Codici di controllo non stampabili e che vengono utilizzati per controllare periferiche. \\ %(come le stampanti). \\
    \hline 
    \textbf{Printable character} [32-127] & 
    %Codes 32-127 are common for all the different variations of the ASCII table, they are called printable characters, represent 
    %letters, digits, punctuation marks, and a few miscellaneous symbols. You will find almost every character on your keyboard. 
    %Character 127 represents the command DEL. 
    Rappresentano lettere, cifre, segni di punteggiatura e vari simboli. \\ 
    \hline 
    \textbf{Extended ASCII Codes} [128-255] & 
    %There are several different variations of the 8-bit ASCII table. 
    I valori fra 128 a 255 non fanno parte dell'ASCII standard; appartengono alla sua versione estesa. I caratteri presenti dipendono 
    dalla codifica utilizzata. La più comune è ISO 8859-1 (chiamata anche ISO Latin-1). \\  
    \hline 
\caption{Struttura della tabella ASCII} 
\label{tabella:ASCII:table} 
\end{longtable} 
\end{center} 
%\vspace{3ex} \newline 
Quindi per poter ridurre la quantità di tempo necessaria per mandare i dati, si è definita una nuova funzione 
che cercerà di normalizzare l'intervallo di tempo, associato al dato, fra un valore minimo e uno massimo. 
%Tramite questa funzione il range dei possibili delay è stato ristretto a due valori precisi e definiti: min\_delay e max\_delay. 
%Questo permetterà di inviare un magigore numero di informazioni in un tempo minore.
%E questo ha permesso l'invio di 72 byte in circa 13/14 minuti. 
In questo caso bisongerà impostare correttamente il valore minimo e quello massimo. 
Minore è la loro differenza maggiore sarà la probabilità che i dati vengano codificati in maniera errata. 
%Il lato negativo è una maggiore possibilità di errore: se il computer che riceve i dati subisce un delay, 
%la possibilità di decodificare il carattere sbagliato è maggiore rispetto ai metodi che implementavano una distanz adi sicurezza. 
%\vspace{1ex} \newline 
%Lo sviluppo di un ulteriore Timing Channel che possa inviare 2 bytes sarebbe difficile. 
%e al momento è possiibile farlo riducendo il massimo tempo di attesa. 
\begin{equation}
    \text{min\_delay}+(\text{byte}/255)*(\text{max\_delay}-\text{min\_delay})
\end{equation} 
\label{equation:2:tempi:timingCC} 
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=0.45\textwidth]{./img/timing_channel/timinmg_channel_2nd_function.png}
    \captionof{figure}{2a funzione: assegnazione degli intervalli} %(Timing Channel) 
\end{minipage} 

%\subsubsection{Timing Channel con tempi casuali} 
\subsubsection{Implementazione finale} 
L'implementazione precedente è stata sviluppata ulteriormente inserendo del rumore al tempo di delay così che per ogni possibile intervallo, 
non sarà più presente un tempo costante fra un pacchetto e il successivo. 
%Quindi invece di aspettare un tempo costante per lo stesso carattere. 
Siccome la quantità di rumore aggiunta dovrà risultare casuale, si è definito un range di tempo nel quale può variare.  
%dipenderà in un determinato range di tempo. %di tempo associato in cui il carattere può variare. 
\vspace{2ex} \newline 
Gli IDS riescono ad individuare gli schemi temporali, 
%si è definito un range così da poter mandare tempi randomici e non costanti. 
quindi definire un range permetterà di non essere rilevati. 
Ora la codifica di un byte, non è più definita da un singolo, costante e prevedibile intervallo di tempo, 
ma da un range di intervalli temporali che continuamente cambiano. 
%Quindi se si volesse mandare il dato \textit{c}, non si aspetteranno più \textit{7} secondi, 
%ma un tempo randomico appartenente al range range $[5,9]$ (supponendo un range di 2 secondi). 
%Inoltre si è pensato di introdurre anche un tempo (in minuti) che definirà quanto aspettare una volta che si è mandato una certa quantità di byte. 
%Ciò potrà essere usato se lo scambio di informazioni risultasse prolungato; 
%un numero elevato e continuo di pacchetti potrebbe risultare anomalo.  
%\vspace{1ex} 
%L'unica differenza presente nella versione (del Timing Channel) che utilizza il protocollo IPV6, 
%è la struttura del pacchetto. 
%Si aggiungerà un livello \textit{Ether} in cui si specifica l'indirizzo MAC di destinazione e l'indirizzo MAC sorgente. 
%Inoltre nel livello \textit{IPv6} bisognerà definire lo ScopeId dell'indirizzo di destinazione; 
%ciò verrà fatto specificanto nel campo non solo l'indirizzo IP di destinazione, 
%ma anche l'interfaccia per poter raggiungerlo. 
%Un livello \textit{Raw} contenente solo il testo '\textit{Hello Neighbour}'.
\begin{minipage}{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./img/timing_channel/timinmg_channel_rumore.png}
    \captionof{figure}{Schema assegnazione dei tempi con rumore} %(Timing Channel) 
\end{minipage} 
\vspace{2ex} \newline
Il mittente e il destinatario devono potersi sincronizzare sulla quantità di rumore si è aggiunto; due strade possibili sono:  
\begin{itemize} 
    \item Nella prima ogni entità crea un numero randomico e bisognerà sincronizzare le due entità sulla quantità e sul valore dei numeri estratti. 
    %(tramite un seed condiviso e con un numero di estrazioni uguale). 
    %Il lato negativo è che 
    Se i numeri non combaciano, %perchè un'entità ha effettuato un numero maggiore o minore di estrazioni, 
    il dato ricavato risulterà non corretto. 
    \item  Il secondo approccio è di mettere il rumore generato nel pacchetto stesso o direttamente nel payload. 
    %Per esempio o tramite uno dei campi, o per esempio il campo identifier. 
    Il ricevente otterrà il valore dalla risorsa condivisa. 
\end{itemize} 

 